<!DOCTYPE html>
<html lang="es" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>NetWithAlex</title>
<meta name="keywords" content="">
<meta name="description" content="Introducción
A medida que las redes evolucionan para proporcionar una mejor experiencia del usuario y se introducen nuevas tecnologías para administrar la red, mantener todo se ejecuta sin problemas se ha vuelto cada vez más difícil. Una de las responsabilidades críticas del equipo de operaciones es el seguimiento de los problemas que ocurren en toda la red. Identificarlos es solo el comienzo, entonces deben registrarse y conducir a la resolución. ¡Multiplique la cantidad de acciones por incidente y tendrá suficiente para mantener a su equipo de TI ocupado todo el día!">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/rastreando-sd-wan-incidents-with-service-ahora%20/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/assets/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/tracking-sd-wan-incidents-with-service-now/">
<link rel="alternate" hreflang="es" href="http://localhost:1313/rastreando-sd-wan-incidents-with-service-ahora%20/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://localhost:1313/rastreando-sd-wan-incidents-with-service-ahora%20/">
  <meta property="og:site_name" content="NetWithAlex">
  <meta property="og:title" content="NetWithAlex">
  <meta property="og:description" content="Introducción A medida que las redes evolucionan para proporcionar una mejor experiencia del usuario y se introducen nuevas tecnologías para administrar la red, mantener todo se ejecuta sin problemas se ha vuelto cada vez más difícil. Una de las responsabilidades críticas del equipo de operaciones es el seguimiento de los problemas que ocurren en toda la red. Identificarlos es solo el comienzo, entonces deben registrarse y conducir a la resolución. ¡Multiplique la cantidad de acciones por incidente y tendrá suficiente para mantener a su equipo de TI ocupado todo el día!">
  <meta property="og:locale" content="es">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="">
<meta name="twitter:description" content="Introducción
A medida que las redes evolucionan para proporcionar una mejor experiencia del usuario y se introducen nuevas tecnologías para administrar la red, mantener todo se ejecuta sin problemas se ha vuelto cada vez más difícil. Una de las responsabilidades críticas del equipo de operaciones es el seguimiento de los problemas que ocurren en toda la red. Identificarlos es solo el comienzo, entonces deben registrarse y conducir a la resolución. ¡Multiplique la cantidad de acciones por incidente y tendrá suficiente para mantener a su equipo de TI ocupado todo el día!">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/es/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "http://localhost:1313/rastreando-sd-wan-incidents-with-service-ahora%20/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "Introducción A medida que las redes evolucionan para proporcionar una mejor experiencia del usuario y se introducen nuevas tecnologías para administrar la red, mantener todo se ejecuta sin problemas se ha vuelto cada vez más difícil. Una de las responsabilidades críticas del equipo de operaciones es el seguimiento de los problemas que ocurren en toda la red. Identificarlos es solo el comienzo, entonces deben registrarse y conducir a la resolución. ¡Multiplique la cantidad de acciones por incidente y tendrá suficiente para mantener a su equipo de TI ocupado todo el día!\n",
  "keywords": [
    
  ],
  "articleBody": "Introducción A medida que las redes evolucionan para proporcionar una mejor experiencia del usuario y se introducen nuevas tecnologías para administrar la red, mantener todo se ejecuta sin problemas se ha vuelto cada vez más difícil. Una de las responsabilidades críticas del equipo de operaciones es el seguimiento de los problemas que ocurren en toda la red. Identificarlos es solo el comienzo, entonces deben registrarse y conducir a la resolución. ¡Multiplique la cantidad de acciones por incidente y tendrá suficiente para mantener a su equipo de TI ocupado todo el día!\nEn esta publicación, le mostraré lo que necesita saber para integrar al gerente de SD-WAN con ServiceNow para la gestión de incidentes. Veremos algunos de los problemas más comunes en SD-WAN.\nConfiguración de laboratorio Estoy usando la versión 20.12.1 de SD-WAN Manager y tengo una instancia de desarrollador de ServiceNow. Mi servidor Webhook se ejecuta en Ubuntu 20.04 LTS y construí el receptor webhook en el idioma GO.\nPara simplificar las cosas, tengo comunicación directa entre todos los elementos de mi laboratorio.\n! [] (/wp-content/uploads/2024/03/snow-1.png)\nwebhooks Webhooks son una forma para que las aplicaciones web se comuniquen entre sí en tiempo real. Permiten que una aplicación envíe notificaciones automatizadas a otra aplicación cuando ocurre un evento específico, se conoce como “modelo de empuje”. Esto facilita la integración entre diferentes sistemas y puede usarse para activar actividades automatizadas posteriores. Webhooks generalmente usan devoluciones de llamada HTTP para compartir notificaciones/información.\nEn nuestro escenario, el gerente de SD-WAN supervisará los eventos en BR10 y enviará solicitudes de publicación HTTP a nuestro servidor webhook cuando ocurran eventos específicos. Esto nos permitirá administrar incidentes en ServiceNow.\nAnatomía de una notificación de webhook Comprendamos la estructura y la información que el administrador de SD-WAN compartirá con nuestro servidor Webhook.\nEste es un ejemplo de la información enviada cuando alguna interfaz va ** abajo **\n{ \"suprimido\": falso, \"dispositivos\": [ { \"System-IP\": \"1.1.10.1\" } ] \"EventName\": \"Interface-State-Change\", \"Tipo\": \"Interface-State-Change\", \"Rulename\": \"Interface-State-Change\", \"componente\": \"VPN\", \"Entry_time\": 1709277345253, \"Statcycletime\": 1709277345253, \"Mensaje\": \"La interfaz Oper-State cambió a down\", \"Severidad\": \"crítica\", \"Severity_Number\": 1, \"uuid\": \"9e2f7630-d504-4cdf-b808-fc8e29a6dd47\", \"Valores\": [ { \"Nombre de host\": \"BR10\", \"System-IP\": \"1.1.10.1\", \"if-name\": \"gigabitethernet2\", \"New-State\": \"Down\", \"VPN-ID\": \"0\" } ] \"Rule_name_display\": \"interface_state_change\", \"Recibe_time\": 1708843127894, \"Values_short_display\": [ { \"Nombre de host\": \"BR10\", \"System-IP\": \"1.1.10.1\", \"if-name\": \"gigabitethernet2\", \"New-State\": \"Down\" } ] \"system_ip\": \"1.1.10.1\", \"host_name\": \"BR10\", \"Reconocido\": Falso, \"Activo\": Verdadero } Extraigamos la información más importante para nosotros:\n\" activo \": Verdadero -- ¿Tenemos un problema? Sí, el problema está activo o presente \" Mensaje \":\" La interfaz operaba ... \" ** - ** ¿Qué está pasando? \" Severity_Number \": 1 ** - ** ¿Qué tan grave es? (Elegimos el número en lugar de la cadena a propósito) -\" uuid \":\" 9e2f7630-d504 ... d47 \" - Identificador de eventos utilizado por el gerente de SD-WAN \" System_ip \":\" 1.1.10.1 \" -- ¿Qué dispositivo originó el evento? \" host_name \":\" BR10 \" -- Identificador de dispositivo más significativo para humanos Veamos la notificación cuando la interfaz llega ** up **\n{ \"suprimido\": falso, \"dispositivos\": [ { \"System-IP\": \"1.1.10.1\" } ] \"EventName\": \"Interface-State-Change\", \"Tipo\": \"Interface-State-Change\", \"Rulename\": \"Interface-State-Change\", \"componente\": \"VPN\", \"Entry_time\": 1709277482508, \"Statcycletime\": 1709277482508, \"Mensaje\": \"La interfaz-estado de operación cambió a UP\", \"Severidad\": \"Medio\", \"Severity_Number\": 3, \"UUID\": \"5486325C-D189-4467-9B5A-16ACB1F28EC9\", \"Valores\": [ { \"Nombre de host\": \"BR10\", \"System-IP\": \"1.1.10.1\", \"if-name\": \"gigabitethernet2\", \"New-State\": \"Up\", \"VPN-ID\": \"0\" } ] \"Rule_name_display\": \"interface_state_change\", \"Recibe_time\": 1708843265147, \"Values_short_display\": [ { \"Nombre de host\": \"BR10\", \"System-IP\": \"1.1.10.1\", \"if-name\": \"gigabitethernet2\", \"New-State\": \"Up\" } ] \"system_ip\": \"1.1.10.1\", \"host_name\": \"BR10\", \"Reconocido\": Falso, \"Cleared_events\": [ \"9E2F7630-D504-4CDF-B808-FC8E29A6DD47\" ] \"Activo\": Falso } Las dos cosas más importantes son:- \" activo \": el problema falso - ya no está activo o presente\n\" Cleared_events \": [\" 9E2F7630-D504 ... D47] \" ** - ** ID de evento que se resuelve Una cosa que debe saber es que no todos los eventos se comportarán de la misma manera. Algunos de ellos no tendrán una entrada de “aclarado \\ _Events”, por lo que tendríamos que manejarlos de manera diferente si queremos cerrarlos automáticamente. Otros pueden carecer de cierta información dependiendo de lo que estemos monitoreando.\nAntes de codificar cualquier tipo de aplicación, es importante saber lo que desea monitorear y lo que obtendrá del administrador SD-WAN para que pueda manejarla correctamente.\nConfigurar webhooks en SD-WAN Manager El 20.12, es muy simple configurarlos, primero habilite la configuración de notificación desde Administración\u003e Configuración\u003e Notificaciones de alarma\n! [] (/wp-content/uploads/2024/03/webhook-2.png)\nDefinamos las reglas para activar nuestros webhooks. Desde monitor\u003e registros\u003e notificación de alarma \u003e Agregar notificación de alarma\n! [] (/wp-content/uploads/2024/03/webhook-4.png)\nCosas que saber:\nPuede optar por monitorear el sitio o los dispositivos. La gravedad es crucial. Para abrir incidentes, generalmente desea monitorear los incidentes críticos y de alta gravedad, para cerrarlos, necesita monitorear severidades más bajas. Las alarmas para las que desea generar webhooks, en nuestro caso BFD Node Down/Up OMP Node Down/Up Control del nodo hacia abajo/arriba Interfaz hacia abajo/UP Tenga en cuenta que solo estoy usando HTTP en mi URL webhook, se recomienda usar HTTPS para una mayor seguridad. El 8080:/Webhook proviene de la aplicación que construimos. El umbral limitará la cantidad de notificaciones enviadas por minuto a esta URL. 15 es suficiente para mí, pero probablemente no para un entorno de producción. Por último, el usuario y la contraseña en caso de que su aplicación Webhook lo requiera. Estos valores serían codificados y enviados en los encabezados. Use valores ficticios si no es necesario. Construya el servidor webhook He publicado el código que usé en el siguiente [Repo de Github] (https://github.com/aruiz-p/sdwan-snow-integración), aquí lo explicaré de una manera más simple.\n** Paso 1: ** Las solicitudes de escucha que vendrán en el puerto 8080 y destinados al punto final/webhook.\n`` // Escucha las próximas solicitudes\nhttp.handlefunc (\"/webhook\", HandleWebhook) fmt.println (“Servidor escucha en el puerto 8080 …”) si err: = http.listenandserve (“0.0.0.0:8080”, nil); err! = nil { fmt.printf (“Error al iniciar el servidor: %v”, err) } ``\n** Paso 2. ** Compruebe si la solicitud entrante tiene un estado activo. En caso afirmativo, cree un incidente en el servicio ahora.\n`` // Verifique si el problema está activo y crea incidentes\nSi datos [“activo”] == true { fmt.println (“Servicio de apertura ahora incidente …”) Err: = CreateInFidident (datos) ``\n** Paso 2.1 ** Para abrir un incidente con el servicio ahora, necesitamos reformatear la información que se enviará allí.\n`` FUNC CreateIndident (Data Map [String] Interface {}) Error {\n// recuperar información para abrir el incidente IssumId: = data [\"uuid\"]. (cadena) RuleName: = data [\"regla_name_display\"]. (cadena) Título: = Data [\"Mensaje\"]. (Cadena) Severidad: = datos [\"Severity_number\"]. (Float64) Severitystr: = strconv.formatfloat (severidad, 'f', -1, 64) dispositivo: = \". dispositivo\" + data [\"host_name\"]. (String) + \", System-IP\" + Data [\"System_ip\"]. (String) // Construye la carga útil JSON para crear incidentes en la nieve IncidentData: = map [string] interfaz {} { \"Categoría\": \"Red\", \"Caller_id\": \"VManage\", \"short_description\": IssisId, \"Descripción\": Rulename + \" -\" + Título + Dispositivo, \"urgencia\": Severitystr, \"Impacto\": Severitystr, } … ``\nObserve que hemos almacenado el uuid proveniente de VManage y lo usamos como ‘short_description `para el servicio ahora.\n** Paso 3.A ** Si el estado ** no ** activo, verificamos si hay algún Cleared_events incluido, esto nos dará una alta precisión al cerrar incidentes.\nif _, ok: = data [\"Cleared_events\"]; OK { ... ClearEdEvents, OK: = data [\"Cleared_events\"]. ([] interfaz {}) EventId: = ClearEdevents [0]. (String) IncidentExists, Incident_id, ERR: = GetincidentWithID (EventId) ... Si incidentExists { Err: = CloseIndrident (incident_id) Para cerrar un caso, necesitamos tener el identificador de servicio ahora llamado _ ** SYS \\ _ID ** _. Para obtenerlo, usamos la función getincidentwithid.\n`` FUNC getincidentwithid (string emitsID) (bool, string, error) { … // Servicio de almacenamiento ahora “Short_description” shortDescription, ok: = incidentMap [“short_description”]. (cadena)\n// Compare la descripción short_descritos con el número if strings.contains (shortDescription, emitsid) { // Si el short_description coincide con el número de emisión, devuelva la identificación del incidente sys_id, ok: = incidentMap [\"sys_id\"]. (cadena) si! ok { continuar } devolver True, sys_id, nil ``\n** Paso 3.B ** Si el estado ** no ** activo y no hay eventos despejados incluidos, vamos a intentar encontrar el incidente que se abrió. Hay tres cosas que verificamos:- ** Nombre de la regla ** - ** Los nombres de reglas para los eventos que estamos monitoreando tendrán la siguiente estructura \\ _ nodo \\ _ . Por ejemplo, bfd_node_down. Si estamos viendo BFD \\ _node \\ _UP, cambiaremos hacia abajo y buscaremos _bfd \\ _node \\ down en los incidentes devueltos desde el servicio ahora. - Sistema IP ** - Almacene el System-IP contenido en la notificación y coincida con la descripción de cada incidente devuelto.\n** Tiempo ** **- ** Almacemos el tiempo ‘Opened_at` y verificamos si tiene menos de 12 horas. Esta es una medida totalmente subjetiva, pero mi idea es que los problemas que tardan más de 12 horas en resolverse, tendrían que ser verificados por algunos humanos. `` FUNC getincidentwoutid (ruleName, sysip string, opentime float64) (bool, string, error) { … // IncidentMap posee los incidentes del servicio ahora description: = IncidentMap [“Descripción”]. (Cadena) Snowtime: = IncidentMap [“Opened_at”]. (Cadena) newrulename: = Strings.replace (Rulename, “Up”, “Down”, -1)\n// Compare el nombre de la regla, la IP y el tiempo del sistema if strings.contains (descripción, newrulename) \u0026\u0026 Strings.contains (descripción, sysip) \u0026\u0026 difusiones \u003c12 { sys_id, ok: = incidentMap [\"sys_id\"]. (cadena) sys_id, ok: = incidentMap [\"sys_id\"]. (cadena) si! ok { continuar } devolver True, sys_id, nil ``\n** Paso 4. ** Cierre el caso con el sys \\ _id obtenido a través de la función getincidentwoutID.\nSi incidentExists { Err: = CloseIndrident (incident_id) si err! = nil { fmt.printf (\"Incidente de cierre de errores: %v \\ n\", err) // manejar el error en consecuencia (por ejemplo, registrarlo, devolver, etc.) devolver } } demás { fmt.printf (\"El incidente no existe o es mayor de 12 horas\") } demostración Comenzaremos ejecutando la aplicación GO. Observe que no estoy usando el código VS para ejecutarlo (CNTRL + F5), sino el terminal para que podamos permitir conexiones entrantes.\n! [] (/wp-content/uploads/2024/03/webhook-3.png)\nNotificación de la interfaz Apagemos una de las interfaces laterales del servicio en el enrutador:\nBR10-1#config-transacción BR10-1 (config)# interfaz gigabitthernet 2 BR10-1 (config-if)# apagado BR10-1 (config-if)# confirmar Comprometerse completo. El servidor recibe la notificación y abre el incidente. El número de incidente es el identificador en el servicio ahora (sys \\ _id)\n! [] (/wp-content/uploads/2024/03/webhook-5-1.png)! [] (/wp-content/uploads/2024/03/webhook-6.png)\nDescubrimos la interfaz y el incidente está cerrado\n! [] (/WP-Content/uploads/2024/03/Webhook-7-1.png)! [] (/wp-content/uploads/2024/03/webhook-9.png)\nObserve que esta notificación tiene la información de “Events \\ _Events”, por lo que es muy fácil encontrar ese incidente en el servicio ahora. Además, la gravedad es ‘Medium’, por eso es importante establecer el valor correcto en la configuración de notificación de alarma.\nObserve que _ ** estado ** _ está resuelto y _ ** notas de resolución ** _ indicar que el incidente se cerró automáticamente a través de Webhooks.\nConexiones de control y notificaciones de BFD Bajemos las sesiones de CCS y BFD cerrando la interfaz de transporte\nBR10-1 (config)# interfaz gigabitethernet 1 BR10-1 (config-if)# sh BR10-1 (config-if)# confirmar Comprometerse completo. Se recibieron notificaciones y se crearon incidentes\n! [] (/WP-Content/uploads/2024/03/Webhook-10.png)! [] (/wp-content/uploads/2024/03/webhook-11.png)\nCuando no envolvemos la interfaz, recibimos las notificaciones y también, registramos el estado del estado de la interfaz para la interfaz GIG 1 y Tunnel1. Todo esto se refleja en el servicio ahora. Estas notificaciones de interfaz no se entregaron antes porque se perdió la conectividad con el gerente de SD-WAN.\n! [] (/wp-content/uploads/2024/03/webhook-12-1.png)! [] (/wp-content/uploads/2024/03/webhook-1.png)\nLecciones aprendidas Es muy importante monitorear el nivel de gravedad correcto, de lo contrario podríamos perder notificaciones para cerrar adecuadamente los incidentes. El gerente de SD-WAN podría ser un poco hablador al generar alertas, el umbral de Webhook se vuelve muy importante y debe probar para venir con un número que funcione para su entorno. El servicio ahora obtendrá una prioridad ** ** basada en la urgencia y el impacto utilizados para crear el boleto. El servicio ahora podría tener algunas políticas que le impedirán cerrar incidentes si no hay cierta información presente en la interfaz de usuario. Esté un poco familiarizado con las políticas de interfaz de usuario y las políticas de datos. Aunque puede establecer manualmente el _sys \\ id “ en el servicio ahora a través de API, sugiero que lo deje solo, ya que poner valores manuales podría causar problemas en el futuro y se supone que este campo es único en toda su instancia. Solo use el valor generado automático. Puede usar sitios públicos como [este] (https://webhook.site), para ver fácilmente el contenido de las notificaciones mientras planifica sus casos de uso. ConclusiónLos webhooks son una excelente manera de monitorear nuestro entorno. Al ser notificado exactamente cuándo ocurre un problema en lugar de confiar en encuestas continuas, aumente nuestra capacidad de iniciar sesión y reaccionar rápidamente a lo que esté sucediendo. Puede combinar webhooks con otro tipo de alertas, como correos electrónicos o incluso chat (webex, holgura, etc.) en caso de que necesite alertar a diferentes equipos. Espero que esta publicación te haya dado algunas ideas o active tu curiosidad. ¡Gracias por leerlo!\n",
  "wordCount" : "2164",
  "inLanguage": "es",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/rastreando-sd-wan-incidents-with-service-ahora%20/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "NetWithAlex",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/assets/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/es/" accesskey="h" title="NetWithAlex (Alt + H)">NetWithAlex</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://localhost:1313/" title="English"
                            aria-label="English">En</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/es/" title="Inicio">
                    <span>Inicio</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/archives/" title="Archivo">
                    <span>Archivo</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/category/" title="Categorías">
                    <span>Categorías</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/about/" title="Sobre mí">
                    <span>Sobre mí</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/search/" title="🔍">
                    <span>🔍</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/es/">Inicio</a>&nbsp;»&nbsp;<a href="http://localhost:1313/es/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">11 min&nbsp;|&nbsp;Traducciones:
<ul class="i18n_list">
    <li>
        <a href="http://localhost:1313/tracking-sd-wan-incidents-with-service-now/">En</a>
    </li>
</ul>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Tabla de Contenidos</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introducci%c3%b3n" aria-label="Introducción">Introducción</a></li>
                <li>
                    <a href="#configuraci%c3%b3n-de-laboratorio" aria-label="Configuración de laboratorio">Configuración de laboratorio</a></li>
                <li>
                    <a href="#webhooks" aria-label="webhooks">webhooks</a><ul>
                        
                <li>
                    <a href="#anatom%c3%ada-de-una-notificaci%c3%b3n-de-webhook" aria-label="Anatomía de una notificación de webhook">Anatomía de una notificación de webhook</a></li></ul>
                </li>
                <li>
                    <a href="#configurar-webhooks-en-sd-wan-manager" aria-label="Configurar webhooks en SD-WAN Manager">Configurar webhooks en SD-WAN Manager</a></li>
                <li>
                    <a href="#construya-el-servidor-webhook" aria-label="Construya el servidor webhook">Construya el servidor webhook</a></li>
                <li>
                    <a href="#demostraci%c3%b3n" aria-label="demostración">demostración</a><ul>
                        
                <li>
                    <a href="#notificaci%c3%b3n-de-la-interfaz" aria-label="Notificación de la interfaz">Notificación de la interfaz</a></li>
                <li>
                    <a href="#conexiones-de-control-y-notificaciones-de-bfd" aria-label="Conexiones de control y notificaciones de BFD">Conexiones de control y notificaciones de BFD</a></li></ul>
                </li>
                <li>
                    <a href="#lecciones-aprendidas" aria-label="Lecciones aprendidas">Lecciones aprendidas</a></li>
                <li>
                    <a href="#conclusi%c3%b3nlos-webhooks-son-una-excelente-manera-de-monitorear-nuestro-entorno-al-ser-notificado-exactamente-cu%c3%a1ndo-ocurre-un-problema-en-lugar-de-confiar-en-encuestas-continuas-aumente-nuestra-capacidad-de-iniciar-sesi%c3%b3n-y-reaccionar-r%c3%a1pidamente-a-lo-que-est%c3%a9-sucediendo-puede-combinar-webhooks-con-otro-tipo-de-alertas-como-correos-electr%c3%b3nicos-o-incluso-chat-webex-holgura-etc-en-caso-de-que-necesite-alertar-a-diferentes-equipos-espero-que-esta-publicaci%c3%b3n-te-haya-dado-algunas-ideas-o-active-tu-curiosidad" aria-label="ConclusiónLos webhooks son una excelente manera de monitorear nuestro entorno. Al ser notificado exactamente cuándo ocurre un problema en lugar de confiar en encuestas continuas, aumente nuestra capacidad de iniciar sesión y reaccionar rápidamente a lo que esté sucediendo. Puede combinar webhooks con otro tipo de alertas, como correos electrónicos o incluso chat (webex, holgura, etc.) en caso de que necesite alertar a diferentes equipos. Espero que esta publicación te haya dado algunas ideas o active tu curiosidad.">ConclusiónLos webhooks son una excelente manera de monitorear nuestro entorno. Al ser notificado exactamente cuándo ocurre un problema en lugar de confiar en encuestas continuas, aumente nuestra capacidad de iniciar sesión y reaccionar rápidamente a lo que esté sucediendo. Puede combinar webhooks con otro tipo de alertas, como correos electrónicos o incluso chat (webex, holgura, etc.) en caso de que necesite alertar a diferentes equipos. Espero que esta publicación te haya dado algunas ideas o active tu curiosidad.</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="introducción">Introducción<a hidden class="anchor" aria-hidden="true" href="#introducción">#</a></h3>
<p>A medida que las redes evolucionan para proporcionar una mejor experiencia del usuario y se introducen nuevas tecnologías para administrar la red, mantener todo se ejecuta sin problemas se ha vuelto cada vez más difícil. Una de las responsabilidades críticas del equipo de operaciones es el seguimiento de los problemas que ocurren en toda la red. Identificarlos es solo el comienzo, entonces deben registrarse y conducir a la resolución. ¡Multiplique la cantidad de acciones por incidente y tendrá suficiente para mantener a su equipo de TI ocupado todo el día!</p>
<p>En esta publicación, le mostraré lo que necesita saber para integrar al gerente de SD-WAN con ServiceNow para la gestión de incidentes. Veremos algunos de los problemas más comunes en SD-WAN.</p>
<h3 id="configuración-de-laboratorio">Configuración de laboratorio<a hidden class="anchor" aria-hidden="true" href="#configuración-de-laboratorio">#</a></h3>
<p>Estoy usando la versión 20.12.1 de SD-WAN Manager y tengo una instancia de desarrollador de ServiceNow. Mi servidor Webhook se ejecuta en Ubuntu 20.04 LTS y construí el receptor webhook en el idioma GO.</p>
<p>Para simplificar las cosas, tengo comunicación directa entre todos los elementos de mi laboratorio.</p>
<p>! [] (/wp-content/uploads/2024/03/snow-1.png)</p>
<h3 id="webhooks">webhooks<a hidden class="anchor" aria-hidden="true" href="#webhooks">#</a></h3>
<p><em>Webhooks</em> son una forma para que las aplicaciones web se comuniquen entre sí en tiempo real. Permiten que una aplicación envíe notificaciones automatizadas a otra aplicación cuando ocurre un evento específico, se conoce como &ldquo;modelo de empuje&rdquo;. Esto facilita la integración entre diferentes sistemas y puede usarse para activar actividades automatizadas posteriores. Webhooks generalmente usan devoluciones de llamada HTTP para compartir notificaciones/información.</p>
<p>En nuestro escenario, el gerente de SD-WAN supervisará los eventos en BR10 y enviará solicitudes de publicación HTTP a nuestro servidor webhook cuando ocurran eventos específicos. Esto nos permitirá administrar incidentes en ServiceNow.</p>
<h4 id="anatomía-de-una-notificación-de-webhook">Anatomía de una notificación de webhook<a hidden class="anchor" aria-hidden="true" href="#anatomía-de-una-notificación-de-webhook">#</a></h4>
<p>Comprendamos la estructura y la información que el administrador de SD-WAN compartirá con nuestro servidor Webhook.</p>
<p>Este es un ejemplo de la información enviada cuando alguna interfaz va ** abajo **</p>
<p><code> </code> <code>{ &quot;suprimido&quot;: falso, &quot;dispositivos&quot;: [ { &quot;System-IP&quot;: &quot;1.1.10.1&quot; } ] &quot;EventName&quot;: &quot;Interface-State-Change&quot;, &quot;Tipo&quot;: &quot;Interface-State-Change&quot;, &quot;Rulename&quot;: &quot;Interface-State-Change&quot;, &quot;componente&quot;: &quot;VPN&quot;, &quot;Entry_time&quot;: 1709277345253, &quot;Statcycletime&quot;: 1709277345253, &quot;Mensaje&quot;: &quot;La interfaz Oper-State cambió a down&quot;, &quot;Severidad&quot;: &quot;crítica&quot;, &quot;Severity_Number&quot;: 1, &quot;uuid&quot;: &quot;9e2f7630-d504-4cdf-b808-fc8e29a6dd47&quot;, &quot;Valores&quot;: [ { &quot;Nombre de host&quot;: &quot;BR10&quot;, &quot;System-IP&quot;: &quot;1.1.10.1&quot;, &quot;if-name&quot;: &quot;gigabitethernet2&quot;, &quot;New-State&quot;: &quot;Down&quot;, &quot;VPN-ID&quot;: &quot;0&quot; } ] &quot;Rule_name_display&quot;: &quot;interface_state_change&quot;, &quot;Recibe_time&quot;: 1708843127894, &quot;Values_short_display&quot;: [ { &quot;Nombre de host&quot;: &quot;BR10&quot;, &quot;System-IP&quot;: &quot;1.1.10.1&quot;, &quot;if-name&quot;: &quot;gigabitethernet2&quot;, &quot;New-State&quot;: &quot;Down&quot; } ] &quot;system_ip&quot;: &quot;1.1.10.1&quot;, &quot;host_name&quot;: &quot;BR10&quot;, &quot;Reconocido&quot;: Falso, &quot;Activo&quot;: Verdadero }</code> <code> </code></p>
<p>Extraigamos la información más importante para nosotros:</p>
<ul>
<li><code>&quot; activo &quot;: Verdadero</code> <code>--</code> ¿Tenemos un problema? Sí, el problema está activo o presente</li>
<li><code>&quot; Mensaje &quot;:&quot; La interfaz operaba ... &quot;</code> ** <code>-</code> ** ¿Qué está pasando?</li>
<li><code>&quot; Severity_Number &quot;: 1</code> ** <code>-</code> ** ¿Qué tan grave es? (Elegimos el número en lugar de la cadena a propósito)
-<code>&quot; uuid &quot;:&quot; 9e2f7630-d504 ... d47 &quot;</code> <code>-</code> Identificador de eventos utilizado por el gerente de SD-WAN</li>
<li><code>&quot; System_ip &quot;:&quot; 1.1.10.1 &quot;</code> <code>--</code> ¿Qué dispositivo originó el evento?</li>
<li><code>&quot; host_name &quot;:&quot; BR10 &quot;</code> <code>--</code> Identificador de dispositivo más significativo para humanos</li>
</ul>
<p>Veamos la notificación cuando la interfaz llega ** up **</p>
<p><code> </code> <code>{ &quot;suprimido&quot;: falso, &quot;dispositivos&quot;: [ { &quot;System-IP&quot;: &quot;1.1.10.1&quot; } ] &quot;EventName&quot;: &quot;Interface-State-Change&quot;, &quot;Tipo&quot;: &quot;Interface-State-Change&quot;, &quot;Rulename&quot;: &quot;Interface-State-Change&quot;, &quot;componente&quot;: &quot;VPN&quot;, &quot;Entry_time&quot;: 1709277482508, &quot;Statcycletime&quot;: 1709277482508, &quot;Mensaje&quot;: &quot;La interfaz-estado de operación cambió a UP&quot;, &quot;Severidad&quot;: &quot;Medio&quot;, &quot;Severity_Number&quot;: 3, &quot;UUID&quot;: &quot;5486325C-D189-4467-9B5A-16ACB1F28EC9&quot;, &quot;Valores&quot;: [ { &quot;Nombre de host&quot;: &quot;BR10&quot;, &quot;System-IP&quot;: &quot;1.1.10.1&quot;, &quot;if-name&quot;: &quot;gigabitethernet2&quot;, &quot;New-State&quot;: &quot;Up&quot;, &quot;VPN-ID&quot;: &quot;0&quot; } ] &quot;Rule_name_display&quot;: &quot;interface_state_change&quot;, &quot;Recibe_time&quot;: 1708843265147, &quot;Values_short_display&quot;: [ { &quot;Nombre de host&quot;: &quot;BR10&quot;, &quot;System-IP&quot;: &quot;1.1.10.1&quot;, &quot;if-name&quot;: &quot;gigabitethernet2&quot;, &quot;New-State&quot;: &quot;Up&quot; } ] &quot;system_ip&quot;: &quot;1.1.10.1&quot;, &quot;host_name&quot;: &quot;BR10&quot;, &quot;Reconocido&quot;: Falso, &quot;Cleared_events&quot;: [ &quot;9E2F7630-D504-4CDF-B808-FC8E29A6DD47&quot; ] &quot;Activo&quot;: Falso }</code> <code> </code></p>
<p>Las dos cosas más importantes son:- <code>&quot; activo &quot;: el problema falso</code> <code>-</code> ya no está activo o presente</p>
<ul>
<li><code>&quot; Cleared_events &quot;: [&quot; 9E2F7630-D504 ... D47] &quot;</code> ** <code>-</code> ** ID de evento que se resuelve</li>
</ul>
<p>Una cosa que debe saber es que no todos los eventos se comportarán de la misma manera. Algunos de ellos no tendrán una entrada de &ldquo;aclarado \ _Events&rdquo;, por lo que tendríamos que manejarlos de manera diferente si queremos cerrarlos automáticamente. Otros pueden carecer de cierta información dependiendo de lo que estemos monitoreando.</p>
<p>Antes de codificar cualquier tipo de aplicación, es importante saber lo que desea monitorear y lo que obtendrá del administrador SD-WAN para que pueda manejarla correctamente.</p>
<h3 id="configurar-webhooks-en-sd-wan-manager">Configurar webhooks en SD-WAN Manager<a hidden class="anchor" aria-hidden="true" href="#configurar-webhooks-en-sd-wan-manager">#</a></h3>
<p>El 20.12, es muy simple configurarlos, primero habilite la configuración de notificación desde <code>Administración&gt; Configuración&gt; Notificaciones de alarma</code></p>
<p>! [] (/wp-content/uploads/2024/03/webhook-2.png)</p>
<p>Definamos las reglas para activar nuestros webhooks. Desde <em><code>monitor&gt; registros&gt; notificación de alarma</code></em> <code>&gt; Agregar notificación de alarma</code></p>
<p>! [] (/wp-content/uploads/2024/03/webhook-4.png)</p>
<p>Cosas que saber:</p>
<ul>
<li>Puede optar por monitorear el sitio o los dispositivos.</li>
<li>La gravedad es crucial. Para abrir incidentes, generalmente desea monitorear los incidentes críticos y de alta gravedad, para cerrarlos, necesita monitorear severidades más bajas.</li>
<li>Las alarmas para las que desea generar webhooks, en nuestro caso
<ul>
<li>BFD Node Down/Up</li>
<li>OMP Node Down/Up</li>
<li>Control del nodo hacia abajo/arriba</li>
<li>Interfaz hacia abajo/UP</li>
</ul>
</li>
<li>Tenga en cuenta que solo estoy usando HTTP en mi URL webhook, se recomienda usar HTTPS para una mayor seguridad. El <code>8080:/Webhook</code> proviene de la aplicación que construimos.</li>
<li>El umbral limitará la cantidad de notificaciones enviadas por minuto a esta URL. 15 es suficiente para mí, pero probablemente no para un entorno de producción.</li>
<li>Por último, el usuario y la contraseña en caso de que su aplicación Webhook lo requiera. Estos valores serían codificados y enviados en los encabezados. Use valores ficticios si no es necesario.</li>
</ul>
<h3 id="construya-el-servidor-webhook">Construya el servidor webhook<a hidden class="anchor" aria-hidden="true" href="#construya-el-servidor-webhook">#</a></h3>
<p>He publicado el código que usé en el siguiente [Repo de Github] (<a href="https://github.com/aruiz-p/sdwan-snow-integraci">https://github.com/aruiz-p/sdwan-snow-integraci</a>ón), aquí lo explicaré de una manera más simple.</p>
<p>** Paso 1: ** Las solicitudes de escucha que vendrán en el puerto <code>8080</code> y destinados al punto final<code>/webhook</code>.</p>
<p><code> </code> ``
// Escucha las próximas solicitudes</p>
<p>http.handlefunc (&quot;/webhook&quot;, HandleWebhook)
fmt.println (&ldquo;Servidor escucha en el puerto 8080 &hellip;&rdquo;)
si err: = http.listenandserve (&ldquo;0.0.0.0:8080&rdquo;, nil); err! = nil {
fmt.printf (&ldquo;Error al iniciar el servidor: %v&rdquo;, err)
}
<code> </code> ``</p>
<p>** Paso 2. ** Compruebe si la solicitud entrante tiene un estado activo. En caso afirmativo, cree un incidente en el servicio ahora.</p>
<p><code> </code> ``
// Verifique si el problema está activo y crea incidentes</p>
<p>Si datos [&ldquo;activo&rdquo;] == true {
fmt.println (&ldquo;Servicio de apertura ahora incidente &hellip;&rdquo;)
Err: = CreateInFidident (datos)
<code> </code> ``</p>
<p>** Paso 2.1 ** Para abrir un incidente con el servicio ahora, necesitamos reformatear la información que se enviará allí.</p>
<p><code> </code> ``
FUNC CreateIndident (Data Map [String] Interface {}) Error {</p>
<pre><code>    // recuperar información para abrir el incidente
IssumId: = data [&quot;uuid&quot;]. (cadena)
RuleName: = data [&quot;regla_name_display&quot;]. (cadena)
Título: = Data [&quot;Mensaje&quot;]. (Cadena)
Severidad: = datos [&quot;Severity_number&quot;]. (Float64)
Severitystr: = strconv.formatfloat (severidad, 'f', -1, 64)
dispositivo: = &quot;. dispositivo&quot; + data [&quot;host_name&quot;]. (String) +
	&quot;, System-IP&quot; + Data [&quot;System_ip&quot;]. (String)

// Construye la carga útil JSON para crear incidentes en la nieve
IncidentData: = map [string] interfaz {} {
	&quot;Categoría&quot;: &quot;Red&quot;,
	&quot;Caller_id&quot;: &quot;VManage&quot;,
	&quot;short_description&quot;: IssisId,
	&quot;Descripción&quot;: Rulename + &quot; -&quot; + Título + Dispositivo,
	&quot;urgencia&quot;: Severitystr,
	&quot;Impacto&quot;: Severitystr,
}
</code></pre>
<p>&hellip;
<code> </code> ``</p>
<p>Observe que hemos almacenado el <code>uuid</code> proveniente de VManage y lo usamos como &lsquo;short_description `para el servicio ahora.</p>
<p>** Paso 3.A ** Si el estado ** no ** activo, verificamos si hay algún <code>Cleared_events</code> incluido, esto nos dará una alta precisión al cerrar incidentes.</p>
<p><code> </code> <code>if _, ok: = data [&quot;Cleared_events&quot;]; OK { ... ClearEdEvents, OK: = data [&quot;Cleared_events&quot;]. ([] interfaz {}) EventId: = ClearEdevents [0]. (String) IncidentExists, Incident_id, ERR: = GetincidentWithID (EventId) ... Si incidentExists { Err: = CloseIndrident (incident_id)</code> <code> </code></p>
<p>Para cerrar un caso, necesitamos tener el identificador de servicio ahora llamado _ ** SYS \ _ID ** _. Para obtenerlo, usamos la función <code>getincidentwithid</code>.</p>
<p><code> </code> ``
FUNC getincidentwithid (string emitsID) (bool, string, error) {
&hellip;
// Servicio de almacenamiento ahora &ldquo;Short_description&rdquo;
shortDescription, ok: = incidentMap [&ldquo;short_description&rdquo;]. (cadena)</p>
<pre><code>    // Compare la descripción short_descritos con el número
if strings.contains (shortDescription, emitsid) {
        // Si el short_description coincide con el número de emisión, devuelva la identificación del incidente
	sys_id, ok: = incidentMap [&quot;sys_id&quot;]. (cadena)
		si! ok {
			continuar
		}
devolver True, sys_id, nil
</code></pre>
<p><code> </code> ``</p>
<p>** Paso 3.B ** Si el estado ** no ** activo y no hay eventos despejados incluidos, vamos a intentar encontrar el incidente que se abrió. Hay tres cosas que verificamos:- ** Nombre de la regla ** <strong>- ** Los nombres de reglas para los eventos que estamos monitoreando tendrán la siguiente estructura <teners> \ _ nodo \ _ <State>. Por ejemplo, <code>bfd_node_down</code>. Si estamos viendo BFD \ _node \ _UP, cambiaremos hacia abajo y buscaremos _bfd \ _node \ <em>down</em> en los incidentes devueltos desde el servicio ahora.
-</strong> Sistema IP ** <strong>-</strong> Almacene el <code>System-IP</code> contenido en la notificación y coincida con la descripción de cada incidente devuelto.</p>
<ul>
<li>** Tiempo ** **- ** Almacemos el tiempo &lsquo;Opened_at` y verificamos si tiene menos de 12 horas. Esta es una medida totalmente subjetiva, pero mi idea es que los problemas que tardan más de 12 horas en resolverse, tendrían que ser verificados por algunos humanos.</li>
</ul>
<p><code> </code> ``
FUNC getincidentwoutid (ruleName, sysip string, opentime float64) (bool, string, error) {
&hellip;
// IncidentMap posee los incidentes del servicio ahora
description: = IncidentMap [&ldquo;Descripción&rdquo;]. (Cadena)
Snowtime: = IncidentMap [&ldquo;Opened_at&rdquo;]. (Cadena)
newrulename: = Strings.replace (Rulename, &ldquo;Up&rdquo;, &ldquo;Down&rdquo;, -1)</p>
<pre><code>  // Compare el nombre de la regla, la IP y el tiempo del sistema
  if strings.contains (descripción, newrulename) &amp;&amp;
      Strings.contains (descripción, sysip) &amp;&amp;
      difusiones &lt;12 {
      sys_id, ok: = incidentMap [&quot;sys_id&quot;]. (cadena)
          sys_id, ok: = incidentMap [&quot;sys_id&quot;]. (cadena)

          si! ok {
              continuar
      }
      devolver True, sys_id, nil
</code></pre>
<p><code> </code> ``</p>
<p>** Paso 4. ** Cierre el caso con el sys \ _id obtenido a través de la función <code>getincidentwoutID</code>.</p>
<p><code> </code> <code>Si incidentExists { Err: = CloseIndrident (incident_id) si err! = nil { fmt.printf (&quot;Incidente de cierre de errores: %v \ n&quot;, err) // manejar el error en consecuencia (por ejemplo, registrarlo, devolver, etc.) devolver } } demás { fmt.printf (&quot;El incidente no existe o es mayor de 12 horas&quot;) }</code> <code> </code></p>
<h3 id="demostración">demostración<a hidden class="anchor" aria-hidden="true" href="#demostración">#</a></h3>
<p>Comenzaremos ejecutando la aplicación GO. Observe que no estoy usando el código VS para ejecutarlo (CNTRL + F5), sino el terminal para que podamos permitir conexiones entrantes.</p>
<p>! [] (/wp-content/uploads/2024/03/webhook-3.png)</p>
<h4 id="notificación-de-la-interfaz">Notificación de la interfaz<a hidden class="anchor" aria-hidden="true" href="#notificación-de-la-interfaz">#</a></h4>
<p>Apagemos una de las interfaces laterales del servicio en el enrutador:</p>
<p><code> </code> <code>BR10-1#config-transacción BR10-1 (config)# interfaz gigabitthernet 2 BR10-1 (config-if)# apagado BR10-1 (config-if)# confirmar Comprometerse completo.</code> <code> </code></p>
<p>El servidor recibe la notificación y abre el incidente. El número de incidente es el identificador en el servicio ahora (sys \ _id)</p>
<p>! [] (/wp-content/uploads/2024/03/webhook-5-1.png)! [] (/wp-content/uploads/2024/03/webhook-6.png)</p>
<p>Descubrimos la interfaz y el incidente está cerrado</p>
<p>! [] (/WP-Content/uploads/2024/03/Webhook-7-1.png)! [] (/wp-content/uploads/2024/03/webhook-9.png)</p>
<p>Observe que esta notificación tiene la información de &ldquo;Events \ _Events&rdquo;, por lo que es muy fácil encontrar ese incidente en el servicio ahora. Además, la gravedad es &lsquo;Medium&rsquo;, por eso es importante establecer el valor correcto en la configuración de notificación de alarma.</p>
<p>Observe que _ ** estado ** _ está <code>resuelto</code> y _ ** notas de resolución ** _ indicar que el incidente se cerró automáticamente a través de Webhooks.</p>
<h4 id="conexiones-de-control-y-notificaciones-de-bfd">Conexiones de control y notificaciones de BFD<a hidden class="anchor" aria-hidden="true" href="#conexiones-de-control-y-notificaciones-de-bfd">#</a></h4>
<p>Bajemos las sesiones de CCS y BFD cerrando la interfaz de transporte</p>
<p><code> </code> <code>BR10-1 (config)# interfaz gigabitethernet 1 BR10-1 (config-if)# sh BR10-1 (config-if)# confirmar Comprometerse completo.</code> <code> </code></p>
<p>Se recibieron notificaciones y se crearon incidentes</p>
<p>! [] (/WP-Content/uploads/2024/03/Webhook-10.png)! [] (/wp-content/uploads/2024/03/webhook-11.png)</p>
<p>Cuando no envolvemos la interfaz, recibimos las notificaciones y también, registramos el estado del estado de la interfaz para la interfaz GIG 1 y Tunnel1. Todo esto se refleja en el servicio ahora. Estas notificaciones de interfaz no se entregaron antes porque se perdió la conectividad con el gerente de SD-WAN.</p>
<p>! [] (/wp-content/uploads/2024/03/webhook-12-1.png)! [] (/wp-content/uploads/2024/03/webhook-1.png)</p>
<h3 id="lecciones-aprendidas">Lecciones aprendidas<a hidden class="anchor" aria-hidden="true" href="#lecciones-aprendidas">#</a></h3>
<ol>
<li>Es muy importante monitorear el nivel de gravedad correcto, de lo contrario podríamos perder notificaciones para cerrar adecuadamente los incidentes.</li>
<li>El gerente de SD-WAN podría ser un poco hablador al generar alertas, el umbral de Webhook se vuelve muy importante y debe probar para venir con un número que funcione para su entorno.</li>
<li>El servicio ahora obtendrá una prioridad ** ** basada en la urgencia y el impacto utilizados para crear el boleto.</li>
<li>El servicio ahora podría tener algunas políticas que le impedirán cerrar incidentes si no hay cierta información presente en la interfaz de usuario. Esté un poco familiarizado con las políticas de interfaz de usuario y las políticas de datos.</li>
<li>Aunque puede establecer manualmente el _sys \ <em>id &ldquo;</em> en el servicio ahora a través de API, sugiero que lo deje solo, ya que poner valores manuales podría causar problemas en el futuro y se supone que este campo es único en toda su instancia. Solo use el valor generado automático.</li>
<li>Puede usar sitios públicos como [este] (<a href="https://webhook.site">https://webhook.site</a>), para ver fácilmente el contenido de las notificaciones mientras planifica sus casos de uso.</li>
</ol>
<h3 id="conclusiónlos-webhooks-son-una-excelente-manera-de-monitorear-nuestro-entorno-al-ser-notificado-exactamente-cuándo-ocurre-un-problema-en-lugar-de-confiar-en-encuestas-continuas-aumente-nuestra-capacidad-de-iniciar-sesión-y-reaccionar-rápidamente-a-lo-que-esté-sucediendo-puede-combinar-webhooks-con-otro-tipo-de-alertas-como-correos-electrónicos-o-incluso-chat-webex-holgura-etc-en-caso-de-que-necesite-alertar-a-diferentes-equipos-espero-que-esta-publicación-te-haya-dado-algunas-ideas-o-active-tu-curiosidad">ConclusiónLos webhooks son una excelente manera de monitorear nuestro entorno. Al ser notificado exactamente cuándo ocurre un problema en lugar de confiar en encuestas continuas, aumente nuestra capacidad de iniciar sesión y reaccionar rápidamente a lo que esté sucediendo. Puede combinar webhooks con otro tipo de alertas, como correos electrónicos o incluso chat (webex, holgura, etc.) en caso de que necesite alertar a diferentes equipos. Espero que esta publicación te haya dado algunas ideas o active tu curiosidad.<a hidden class="anchor" aria-hidden="true" href="#conclusiónlos-webhooks-son-una-excelente-manera-de-monitorear-nuestro-entorno-al-ser-notificado-exactamente-cuándo-ocurre-un-problema-en-lugar-de-confiar-en-encuestas-continuas-aumente-nuestra-capacidad-de-iniciar-sesión-y-reaccionar-rápidamente-a-lo-que-esté-sucediendo-puede-combinar-webhooks-con-otro-tipo-de-alertas-como-correos-electrónicos-o-incluso-chat-webex-holgura-etc-en-caso-de-que-necesite-alertar-a-diferentes-equipos-espero-que-esta-publicación-te-haya-dado-algunas-ideas-o-active-tu-curiosidad">#</a></h3>
<p>¡Gracias por leerlo!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/es/">NetWithAlex</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copiar';

        function copyingDone() {
            copybutton.innerHTML = '¡copiado!';
            setTimeout(() => {
                copybutton.innerHTML = 'copiar';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
