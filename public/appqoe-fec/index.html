<!DOCTYPE html>
<html lang="es" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Serie AppQoe: Forward Error Correction (FEC) | NetWithAlex</title>
<meta name="keywords" content="">
<meta name="description" content="Aprende cómo funciona Forward Error Correction (FEC) en Cisco SD-WAN para mejorar el rendimiento de las aplicaciones en enlaces con pérdida de paquetes. Explora casos de uso, configuración y resultados de pruebas.">
<meta name="author" content="Alex">
<link rel="canonical" href="http://localhost:1313/appqoe-fec/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/assets/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/appqoe-fec/">
<link rel="alternate" hreflang="es" href="http://localhost:1313/appqoe-fec/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>















    
        <link rel="preconnect" href="https://plausible.io">
    
        <!-- Dev mode : We do not load plausible script to avoid bloating your stats -->

<!-- If you are using Content-Security-Policy, do not forget to add this code to your CSP : 
  script-src 'unsafe-inline' https://plausible.io
  connect-src 'unsafe-inline' https://plausible.io
  or just add the partial 'plausible_csp.html' to those 2 csp directives in your 'index.headers' file
-->



    
    <script>window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }</script>
    <script>
         
         
         
    </script>

    
<meta property="og:url" content="http://localhost:1313/appqoe-fec/">
  <meta property="og:site_name" content="NetWithAlex">
  <meta property="og:title" content="Serie AppQoe: Forward Error Correction (FEC)">
  <meta property="og:description" content="Aprende cómo funciona Forward Error Correction (FEC) en Cisco SD-WAN para mejorar el rendimiento de las aplicaciones en enlaces con pérdida de paquetes. Explora casos de uso, configuración y resultados de pruebas.">
  <meta property="og:locale" content="es">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-05-19T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-05-19T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Serie AppQoe: Forward Error Correction (FEC)">
<meta name="twitter:description" content="Aprende cómo funciona Forward Error Correction (FEC) en Cisco SD-WAN para mejorar el rendimiento de las aplicaciones en enlaces con pérdida de paquetes. Explora casos de uso, configuración y resultados de pruebas.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/es/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Serie AppQoe: Forward Error Correction (FEC)",
      "item": "http://localhost:1313/appqoe-fec/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Serie AppQoe: Forward Error Correction (FEC)",
  "name": "Serie AppQoe: Forward Error Correction (FEC)",
  "description": "Aprende cómo funciona Forward Error Correction (FEC) en Cisco SD-WAN para mejorar el rendimiento de las aplicaciones en enlaces con pérdida de paquetes. Explora casos de uso, configuración y resultados de pruebas.",
  "keywords": [
    
  ],
  "articleBody": "Introducción Ofrecer un rendimiento de aplicación consistente sobre enlaces congestionados o poco confiables es un desafío constante para la mayoría de las redes. Incluso con funciones avanzadas como Enhanced Application-Aware Routing u Optimización TCP, hay condiciones en los enlaces que van más allá de lo que el failover, el balanceo de carga o la optimización pueden resolver.\nAl agregar un mecanismo de recuperación a nivel de paquete, FEC permite que Cisco SD-WAN enmascare la pérdida de paquetes y mantenga el rendimiento de las aplicaciones sin depender de retransmisiones.\nEn este post, exploraremos qué tan efectivo puede ser FEC en un entorno SD-WAN, simulando condiciones con pérdida de paquetes y midiendo las tasas de recuperación.\nSi estás evaluando FEC para tu despliegue o simplemente tienes curiosidad sobre cómo funciona, este artículo te llevará por la teoría y la práctica.\nVamos allá!\nQué es Forward Error Correction (FEC)? Forward Error Correction (FEC) es una técnica que mejora la confiabilidad de la transmisión de datos añadiendo información redundante a los paquetes antes de enviarlos por la red. En lugar de esperar retransmisiones cuando se pierden paquetes, el receptor utiliza esa redundancia para reconstruir los datos faltantes en tiempo real.\nEn la implementación de Cisco SD-WAN, FEC agrupa 4 paquetes de datos y agrega 1 paquete de paridad. Si uno de esos 4 paquetes se pierde en el camino, el receptor puede reconstruirlo utilizando el paquete de paridad mediante una operación XOR.\nVeámoslo en un diagrama:\nEl remitente transmite la información al receptor, pero el paquete 3 se pierde en tránsito. El receptor puede usar el paquete de paridad para reconstruir el paquete 3 y así evitar retransmisiones y retrasos que afectarían la experiencia de las aplicaciones.\nEs importante notar que si se pierden más de 1 paquete, incluyendo el de paridad, no es posible reconstruir la información. El tamaño del bloque es siempre de 4 paquetes de datos + 1 de paridad y no puede modificarse. Un bloque puede contener paquetes de diferentes flujos.\nNota El hecho de que FEC agregue 1 paquete de paridad por cada bloque de 4 incrementa el consumo de ancho de banda.\nHay dos modos de operación:\nAlways: Se aplica FEC a todo el tráfico que haga match a la política, sin importar la cantidad de pérdida de paquetes en el transporte. Adaptive: Permite definir un threshold de pérdida de paquetes antes de empezar a aplicar FEC. Por ejemplo, si hay 2% o más pérdida de paquetes, se debe aplicar FEC al tráfico. El porcentaje de pérdida de paquetes se saca con los paquetes BFD. FEC es especialmente útil en aplicaciones en tiempo real como voz, video o sesiones interactivas, donde esperar retransmisiones provocaría retrasos severos.\nUn punto importante es que FEC opera entre los dispositivos edge de SD-WAN, lo que lo hace completamente transparente para las aplicaciones: no es necesario modificar el comportamiento de clientes o servidores. Sin embargo, solo funciona cuando se utiliza encapsulación IPSec; no está soportado sobre túneles GRE.\nUn detalle crítico de implementación es el tamaño de los paquetes: si los paquetes son demasiado grandes y terminan siendo fragmentados, la capacidad de FEC para reconstruirlos se reduce considerablemente. Para aprovechar al máximo FEC, asegúrate de que el payload se mantenga por debajo del MTU del path MTU para evitar la fragmentación.\nConfiguración Utilizando Policy Groups, podemos configurar FEC a través de política de datos que hagan match al tráfico y apliquen la acción Loss Correction\nEn mi caso, hice match a a todo el tráfico entre 172.16.10.0/24 y 172.16.100.0/24. Nota que se tienen los dos modos de operación: Always y Adaptive\nSi se selecciona FEC Adaptive, el threshold tiene que estar entre 1% y 5% pérdida de paquetes.\nEstá es la configuración completa de mi política:\nvsmart_1# show running-config policy policy data-policy data_all_FEC vpn-list vpn_Corporate_Users sequence 1 match source-ip 172.16.100.0/24 destination-ip 172.16.10.0/24 ! action accept loss-protect fec-always loss-protection forward-error-correction always ! ! sequence 11 match source-ip 172.16.10.0/24 destination-ip 172.16.100.0/24 ! action accept loss-protect fec-always loss-protection forward-error-correction always ! ! default-action accept ! ! lists vpn-list vpn_Corporate_Users vpn 10 ! site-list site_10_100 site-id 10 site-id 100 ! ! apply-policy site-list site_10_100 data-policy data_all_FEC from-service ! ! ! Verificación de FEC No hay muchos comandos relacionados a FEC, pero podemos confirmar que FEC está operando con el siguiente comando:\nMunich_DC100-1#show sdwan tunnel statistics fec tunnel stats ipsec 21.101.0.2 21.11.0.2 12346 12346 fec-rx-data-pkts 16243 fec-rx-parity-pkts 4075 fec-tx-data-pkts 7 fec-tx-parity-pkts 1 fec-reconstruct-pkts 935 fec-capable true fec-dynamic false El fec-reconstruct-pkts indica que se recuperaron 935 paquetes\nNota también que podemos fácilmente ver la cantidad de paquetes de paridad que se enviaron y recibieron siendo aproximadamente 1/4 del total de paquetes de datos enviados/recibidos.\nLa misma información está también disponible a través de la interfaz gráfica del Manager, en la opción de real time\nProbando FEC A bandwidth of 450k is around 5 VoIP calls and using a payload of 361 bytes.\nIn this case, I am running unidirectional tests, but keep in mind FEC works in both directions.\nVamos a realizar algunas pruebas para ver FEC en acción y analizar la cantidad de pérdida de paquetes que puede recuperar. Mostraré distintos resultados para entender en qué condiciones FEC ofrece mejores beneficios.\nNota existe cierta pérdida de paquetes fuera de los routers SD-WAN que no puedo controlar. Por eso, para obtener resultados más precisos, primero tuve que encontrar una tasa de transmisión con la que obtuviera 0% de pérdida la mayor parte del tiempo en mis resultados con iperf3, y a partir de ahí comencé a introducir pérdida de manera controlada.\niperf -c 172.16.100.11 -u -b 450k -t 30 -l 361 –dscp ef\nUn ancho de banda de 450 kbps equivale aproximadamente a 5 llamadas VoIP, utilizando un payload de 361 bytes.\nEn este caso, estoy realizando pruebas unidireccionales, pero ten en cuenta que FEC funciona en ambos sentidos.\n% Pérdida Total Paquetes enviados Total Paquetes recibidos Paquetes recuperados % efectivo de pérdida 1 4693 4639 54 0 2 4694 4588 96 0,24 3 4693 4558 111 0,58 4 4694 4524 147 0,51 5 4693 4448 195 0,68 6 4693 4401 231 1,3 7 4693 4374 238 1,8 8 4693 4331 283 1,8 9 4693 4292 297 2,2 10 4693 4215 304 3,8 12 4693 4122 348 3,8 15 4695 3941 382 8 18 4696 3815 356 11 20 4696 3731 368 13 Veamos unas gráficas interesantes:\nA medida que aumenta la pérdida de paquetes, también crece el número de paquetes recuperados, hasta cierto punto. Esto es esperable: FEC agrega redundancia, y cuanto más se pierde, más se necesita recuperar. Sin embargo, esta capacidad tiene un límite natural: si se pierden dos o más paquetes dentro del mismo bloque FEC —incluyendo el paquete de paridad— la recuperación ya no es posible y la pérdida efectiva comienza a aumentar.\nTambién es importante destacar que FEC es una función utiliza muchos recursos, por lo que se recomienda activarla solo para tráfico crítico y, preferentemente, en combinación con un threshold de pérdida de paquetes, en lugar de mantenerla activa permanentemente.\nAunque este laboratorio no replica a la perfección un entorno de producción, los resultados son bastante reveladores. FEC logró recuperar prácticamente todos los paquetes perdidos con hasta un 5% de pérdida introducida, y continuó recuperando cerca del 70% de los paquetes a aproximadamente 9% de pérdida. A partir de ahí, la eficiencia de recuperación empieza a disminuir. Dicho esto, no es común ver pérdidas constantes superiores al 10% en enlaces WAN de producción, y menos aún en ambas direcciones.\nPor último, aunque las pruebas fueron unidireccionales, vale la pena mencionar que FEC puede aplicarse de forma independiente en cada dirección. Esto significa que, con una implementación bien ajustada, se podría tolerar cerca de un 5% de pérdida de paquetes por dirección sin afectar significativamente el rendimiento.\nConclusion Forward Error Correction (FEC) es una técnica proactiva que agrega redundancia antes de la transmisión de paquetes, permitiendo que el receptor recupere ciertas pérdidas sin necesidad de retransmisiones. Esto la hace especialmente valiosa para aplicaciones en tiempo real como voz o video, donde esperar retransmisiones generaría retrasos perjudiciales.\nRecuerda que habilitar FEC viene con un costo: introduce carga adicional. El edge de SD-WAN que recibe los paquetes necesita usar capacidad de procesamiento adicional para reconstruir los que se perdieron. Por eso, es recomendable activarlo solo para tráfico crítico y, en lo posible, hacerlo condicionado a un threshold de pérdida de paquetes.\nFEC no reemplaza la necesidad de corregir enlaces de red defectuosos. Más bien, actúa como una capa de mitigación inteligente que ayuda a suavizar pérdidas moderadas o transitorias, manteniendo una experiencia de usuario consistente incluso cuando la red no es perfecta.\nEn resumen, cuando se implementa correctamente, FEC puede ser una herramienta muy poderosa en tu arquitectura SD-WAN, ayudando a garantizar un rendimiento de aplicaciones constante sobre redes imperfectas.\n💭 ¿Qué opinas sobre el uso de Forward Error Correction en SD-WAN? ¿Lo has utilizado antes? ¿Tienes dudas sobre cómo funciona o cuándo activarlo?\nDéjame tus comentarios, preguntas o experiencias. Me encantaría saber cómo están abordando esta función en sus despliegues reales. ¡Aprendamos entre todos!\n",
  "wordCount" : "1510",
  "inLanguage": "es",
  "datePublished": "2025-05-19T00:00:00Z",
  "dateModified": "2025-05-19T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Alex"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/appqoe-fec/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "NetWithAlex",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/assets/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/es/" accesskey="h" title="NetWithAlex (Alt + H)">NetWithAlex</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://localhost:1313/" title="English"
                            aria-label="English">En</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/es/" title="Inicio">
                    <span>Inicio</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/archives/" title="Archivo">
                    <span>Archivo</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/category/" title="Categorías">
                    <span>Categorías</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/sobre-mi/" title="Sobre mí">
                    <span>Sobre mí</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/search/" title="🔍">
                    <span>🔍</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/es/">Inicio</a>&nbsp;»&nbsp;<a href="http://localhost:1313/es/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Serie AppQoe: Forward Error Correction (FEC)
    </h1>
    <div class="post-description">
      Aprende cómo funciona Forward Error Correction (FEC) en Cisco SD-WAN para mejorar el rendimiento de las aplicaciones en enlaces con pérdida de paquetes. Explora casos de uso, configuración y resultados de pruebas.
    </div>
    <div class="post-meta"><span title='2025-05-19 00:00:00 +0000 +0000'>mayo 19, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Alex&nbsp;|&nbsp;Traducciones:
<ul class="i18n_list">
    <li>
        <a href="http://localhost:1313/appqoe-fec/">En</a>
    </li>
</ul>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Tabla de Contenidos</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introducci%c3%b3n" aria-label="Introducción">Introducción</a></li>
                <li>
                    <a href="#qu%c3%a9-es-forward-error-correction-fec" aria-label="Qué es Forward Error Correction (FEC)?">Qué es Forward Error Correction (FEC)?</a></li>
                <li>
                    <a href="#configuraci%c3%b3n" aria-label="Configuración">Configuración</a></li>
                <li>
                    <a href="#verificaci%c3%b3n-de-fec" aria-label="Verificación de FEC">Verificación de FEC</a></li>
                <li>
                    <a href="#probando-fec" aria-label="Probando FEC">Probando FEC</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="introducción">Introducción<a hidden class="anchor" aria-hidden="true" href="#introducción">#</a></h2>
<p>Ofrecer un rendimiento de aplicación consistente sobre enlaces congestionados o poco confiables es un desafío constante para la mayoría de las redes. Incluso con funciones avanzadas como <a href="/aar-mejorado/">Enhanced Application-Aware Routing</a> u <a href="/appqoe-opt-tcp/">Optimización TCP</a>, hay condiciones en los enlaces que van más allá de lo que el failover, el balanceo de carga o la optimización pueden resolver.</p>
<p>Al agregar un mecanismo de recuperación a nivel de paquete, FEC permite que Cisco SD-WAN enmascare la pérdida de paquetes y mantenga el rendimiento de las aplicaciones sin depender de retransmisiones.</p>
<p>En este post, exploraremos qué tan efectivo puede ser FEC en un entorno SD-WAN, simulando condiciones con pérdida de paquetes y midiendo las tasas de recuperación.</p>
<p>Si estás evaluando FEC para tu despliegue o simplemente tienes curiosidad sobre cómo funciona, este artículo te llevará por la teoría y la práctica.</p>
<p>Vamos allá!</p>
<h2 id="qué-es-forward-error-correction-fec">Qué es Forward Error Correction (FEC)?<a hidden class="anchor" aria-hidden="true" href="#qué-es-forward-error-correction-fec">#</a></h2>
<p>Forward Error Correction (FEC) es una técnica que mejora la confiabilidad de la transmisión de datos añadiendo información redundante a los paquetes antes de enviarlos por la red. En lugar de esperar retransmisiones cuando se pierden paquetes, el receptor utiliza esa redundancia para reconstruir los datos faltantes en tiempo real.</p>
<p>En la implementación de Cisco SD-WAN, FEC agrupa 4 paquetes de datos y agrega 1 <em>paquete de paridad</em>. Si <strong>uno</strong> de esos 4 paquetes se pierde en el camino, el receptor puede reconstruirlo utilizando el paquete de paridad mediante una operación XOR.</p>
<p>Veámoslo en un diagrama:</p>
<p><img loading="lazy" src="/wp-content/uploads/2025/05/fec1.png"></p>
<p>El remitente transmite la información al receptor, pero el paquete 3 se pierde en tránsito. El receptor puede usar el paquete de paridad para reconstruir el paquete 3 y así evitar retransmisiones y retrasos que afectarían la experiencia de las aplicaciones.</p>
<p>Es importante notar que si se pierden más de 1 paquete, incluyendo el de paridad, no es posible reconstruir la información. El tamaño del bloque es siempre de 4 paquetes de datos + 1 de paridad y no puede modificarse. Un bloque puede contener paquetes de diferentes flujos.</p>
<blockquote>
<p><strong>Nota</strong> El hecho de que FEC agregue 1 paquete de paridad por cada bloque de 4 incrementa el consumo de ancho de banda.</p>
</blockquote>
<p>Hay dos modos de operación:</p>
<ul>
<li><strong>Always</strong>: Se aplica FEC a todo el tráfico que haga match a la política, sin importar la cantidad de pérdida de paquetes en el transporte.</li>
<li><strong>Adaptive</strong>: Permite definir un <em>threshold</em> de pérdida de paquetes antes de empezar a aplicar FEC. Por ejemplo, si hay 2% o más pérdida de paquetes, se debe aplicar FEC al tráfico. El porcentaje de pérdida de paquetes se saca con los <a href="/simplificando-aar-1-3-las-bases/#bfd/">paquetes BFD</a>.</li>
</ul>
<p>FEC es especialmente útil en aplicaciones en tiempo real como voz, video o sesiones interactivas, donde esperar retransmisiones provocaría retrasos severos.</p>
<p>Un punto importante es que FEC opera entre los dispositivos edge de SD-WAN, lo que lo hace completamente transparente para las aplicaciones: no es necesario modificar el comportamiento de clientes o servidores. Sin embargo, solo funciona cuando se utiliza encapsulación IPSec; <strong>no está soportado sobre túneles GRE.</strong></p>
<p>Un detalle crítico de implementación es el tamaño de los paquetes: si los paquetes son demasiado grandes y terminan siendo fragmentados, la capacidad de FEC para reconstruirlos se reduce considerablemente. Para aprovechar al máximo FEC, asegúrate de que el <em>payload</em> se mantenga por debajo del MTU del <em>path MTU</em> para evitar la fragmentación.</p>
<h2 id="configuración">Configuración<a hidden class="anchor" aria-hidden="true" href="#configuración">#</a></h2>
<p>Utilizando <em>Policy Groups</em>, podemos configurar FEC a través de política de datos que hagan match al tráfico y apliquen la acción <em>Loss Correction</em></p>
<p><img loading="lazy" src="/wp-content/uploads/2025/05/fec2.png"></p>
<p>En mi caso, hice match a a todo el tráfico entre 172.16.10.0/24 y 172.16.100.0/24. Nota que se tienen los dos modos de operación: <em>Always y Adaptive</em></p>
<p>Si se selecciona FEC Adaptive, el <em>threshold</em> tiene que estar entre 1% y 5% pérdida de paquetes.</p>
<p>Está es la configuración completa de mi política:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>vsmart_1# show running-config policy 
</span></span><span style="display:flex;"><span>policy
</span></span><span style="display:flex;"><span> data-policy data_all_FEC
</span></span><span style="display:flex;"><span>  vpn-list vpn_Corporate_Users
</span></span><span style="display:flex;"><span>   sequence 1
</span></span><span style="display:flex;"><span>    match
</span></span><span style="display:flex;"><span>     source-ip      172.16.100.0/24
</span></span><span style="display:flex;"><span>     destination-ip 172.16.10.0/24
</span></span><span style="display:flex;"><span>    !
</span></span><span style="display:flex;"><span>    action accept
</span></span><span style="display:flex;"><span>     loss-protect fec-always
</span></span><span style="display:flex;"><span>     loss-protection forward-error-correction always
</span></span><span style="display:flex;"><span>    !
</span></span><span style="display:flex;"><span>   !
</span></span><span style="display:flex;"><span>   sequence 11
</span></span><span style="display:flex;"><span>    match
</span></span><span style="display:flex;"><span>     source-ip      172.16.10.0/24
</span></span><span style="display:flex;"><span>     destination-ip 172.16.100.0/24
</span></span><span style="display:flex;"><span>    !
</span></span><span style="display:flex;"><span>    action accept
</span></span><span style="display:flex;"><span>     loss-protect fec-always
</span></span><span style="display:flex;"><span>     loss-protection forward-error-correction always
</span></span><span style="display:flex;"><span>    !
</span></span><span style="display:flex;"><span>   !
</span></span><span style="display:flex;"><span>   default-action accept
</span></span><span style="display:flex;"><span>  !
</span></span><span style="display:flex;"><span> !
</span></span><span style="display:flex;"><span> lists
</span></span><span style="display:flex;"><span>  vpn-list vpn_Corporate_Users
</span></span><span style="display:flex;"><span>   vpn 10
</span></span><span style="display:flex;"><span>  !
</span></span><span style="display:flex;"><span>  site-list site_10_100
</span></span><span style="display:flex;"><span>   site-id 10
</span></span><span style="display:flex;"><span>   site-id 100
</span></span><span style="display:flex;"><span>  !
</span></span><span style="display:flex;"><span> !
</span></span><span style="display:flex;"><span> apply-policy
</span></span><span style="display:flex;"><span> site-list site_10_100
</span></span><span style="display:flex;"><span>  data-policy data_all_FEC from-service
</span></span><span style="display:flex;"><span> !
</span></span><span style="display:flex;"><span>!
</span></span><span style="display:flex;"><span>!
</span></span></code></pre></div><h2 id="verificación-de-fec">Verificación de FEC<a hidden class="anchor" aria-hidden="true" href="#verificación-de-fec">#</a></h2>
<p>No hay muchos comandos relacionados a FEC, pero podemos confirmar que FEC está operando con el siguiente comando:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gdscript3" data-lang="gdscript3"><span style="display:flex;"><span>Munich_DC100<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#75715e">#show sdwan tunnel statistics fec </span>
</span></span><span style="display:flex;"><span>tunnel stats ipsec <span style="color:#ae81ff">21.101</span><span style="color:#f92672">.</span><span style="color:#ae81ff">0.2</span> <span style="color:#ae81ff">21.11</span><span style="color:#f92672">.</span><span style="color:#ae81ff">0.2</span> <span style="color:#ae81ff">12346</span> <span style="color:#ae81ff">12346</span>
</span></span><span style="display:flex;"><span> fec<span style="color:#f92672">-</span>rx<span style="color:#f92672">-</span>data<span style="color:#f92672">-</span>pkts     <span style="color:#ae81ff">16243</span>
</span></span><span style="display:flex;"><span> fec<span style="color:#f92672">-</span>rx<span style="color:#f92672">-</span>parity<span style="color:#f92672">-</span>pkts   <span style="color:#ae81ff">4075</span>
</span></span><span style="display:flex;"><span> fec<span style="color:#f92672">-</span>tx<span style="color:#f92672">-</span>data<span style="color:#f92672">-</span>pkts     <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span> fec<span style="color:#f92672">-</span>tx<span style="color:#f92672">-</span>parity<span style="color:#f92672">-</span>pkts   <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> fec<span style="color:#f92672">-</span>reconstruct<span style="color:#f92672">-</span>pkts <span style="color:#ae81ff">935</span>
</span></span><span style="display:flex;"><span> fec<span style="color:#f92672">-</span>capable          true
</span></span><span style="display:flex;"><span> fec<span style="color:#f92672">-</span>dynamic          false
</span></span></code></pre></div><p>El <em>fec-reconstruct-pkts</em> indica que se recuperaron 935 paquetes</p>
<p>Nota también que podemos fácilmente ver la cantidad de paquetes de paridad que se enviaron y recibieron siendo aproximadamente 1/4 del total de paquetes de datos enviados/recibidos.</p>
<p>La misma información está también disponible a través de la interfaz gráfica del Manager, en la opción de <em>real time</em></p>
<p><img loading="lazy" src="/wp-content/uploads/2025/05/fec3.png"></p>
<h2 id="probando-fec">Probando FEC<a hidden class="anchor" aria-hidden="true" href="#probando-fec">#</a></h2>
<p>A bandwidth of 450k is <strong>around</strong> 5 VoIP calls and using a payload of 361 bytes.</p>
<p>In this case, I am running unidirectional tests, but keep in mind FEC works in both directions.</p>
<p>Vamos a realizar algunas pruebas para ver FEC en acción y analizar la cantidad de pérdida de paquetes que puede recuperar. Mostraré distintos resultados para entender en qué condiciones FEC ofrece mejores beneficios.</p>
<p><strong>Nota</strong> existe cierta pérdida de paquetes fuera de los routers SD-WAN que no puedo controlar. Por eso, para obtener resultados más precisos, primero tuve que encontrar una tasa de transmisión con la que obtuviera 0% de pérdida la <strong>mayor parte del tiempo</strong> en mis resultados con iperf3, y a partir de ahí comencé a introducir pérdida de manera controlada.</p>
<blockquote>
<p>iperf -c 172.16.100.11 -u -b 450k -t 30 -l 361 &ndash;dscp ef</p>
</blockquote>
<p>Un ancho de banda de 450 kbps equivale aproximadamente a 5 llamadas VoIP, utilizando un <em>payload</em> de 361 bytes.</p>
<p>En este caso, estoy realizando pruebas unidireccionales, pero ten en cuenta que FEC funciona en ambos sentidos.</p>
<table>
  <thead>
      <tr>
          <th>% Pérdida</th>
          <th>Total Paquetes enviados</th>
          <th>Total Paquetes recibidos</th>
          <th>Paquetes recuperados</th>
          <th>% efectivo de pérdida</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>4693</td>
          <td>4639</td>
          <td>54</td>
          <td>0</td>
      </tr>
      <tr>
          <td>2</td>
          <td>4694</td>
          <td>4588</td>
          <td>96</td>
          <td>0,24</td>
      </tr>
      <tr>
          <td>3</td>
          <td>4693</td>
          <td>4558</td>
          <td>111</td>
          <td>0,58</td>
      </tr>
      <tr>
          <td>4</td>
          <td>4694</td>
          <td>4524</td>
          <td>147</td>
          <td>0,51</td>
      </tr>
      <tr>
          <td>5</td>
          <td>4693</td>
          <td>4448</td>
          <td>195</td>
          <td>0,68</td>
      </tr>
      <tr>
          <td>6</td>
          <td>4693</td>
          <td>4401</td>
          <td>231</td>
          <td>1,3</td>
      </tr>
      <tr>
          <td>7</td>
          <td>4693</td>
          <td>4374</td>
          <td>238</td>
          <td>1,8</td>
      </tr>
      <tr>
          <td>8</td>
          <td>4693</td>
          <td>4331</td>
          <td>283</td>
          <td>1,8</td>
      </tr>
      <tr>
          <td>9</td>
          <td>4693</td>
          <td>4292</td>
          <td>297</td>
          <td>2,2</td>
      </tr>
      <tr>
          <td>10</td>
          <td>4693</td>
          <td>4215</td>
          <td>304</td>
          <td>3,8</td>
      </tr>
      <tr>
          <td>12</td>
          <td>4693</td>
          <td>4122</td>
          <td>348</td>
          <td>3,8</td>
      </tr>
      <tr>
          <td>15</td>
          <td>4695</td>
          <td>3941</td>
          <td>382</td>
          <td>8</td>
      </tr>
      <tr>
          <td>18</td>
          <td>4696</td>
          <td>3815</td>
          <td>356</td>
          <td>11</td>
      </tr>
      <tr>
          <td>20</td>
          <td>4696</td>
          <td>3731</td>
          <td>368</td>
          <td>13</td>
      </tr>
  </tbody>
</table>
<p>Veamos unas gráficas interesantes:</p>
<p><img loading="lazy" src="/wp-content/uploads/2025/05/fec4.png">
<img loading="lazy" src="/wp-content/uploads/2025/05/fec5.png">
<img loading="lazy" src="/wp-content/uploads/2025/05/fec6.png"></p>
<p>A medida que aumenta la pérdida de paquetes, también crece el número de paquetes recuperados, hasta cierto punto. Esto es esperable: FEC agrega redundancia, y cuanto más se pierde, más se necesita recuperar. Sin embargo, esta capacidad tiene un límite natural: si se pierden dos o más paquetes dentro del mismo bloque FEC —incluyendo el paquete de paridad— la recuperación ya no es posible y la pérdida efectiva comienza a aumentar.</p>
<p>También es importante destacar que FEC es una función <strong>utiliza muchos recursos</strong>, por lo que se recomienda activarla solo para tráfico crítico y, preferentemente, en combinación con un <em>threshold</em> de pérdida de paquetes, en lugar de mantenerla activa permanentemente.</p>
<p>Aunque este laboratorio no replica a la perfección un entorno de producción, los resultados son bastante reveladores. FEC logró recuperar prácticamente todos los paquetes perdidos con hasta un 5% de pérdida introducida, y continuó recuperando cerca del 70% de los paquetes a aproximadamente 9% de pérdida. A partir de ahí, la eficiencia de recuperación empieza a disminuir. Dicho esto, no es común ver pérdidas constantes superiores al 10% en enlaces WAN de producción, y menos aún en ambas direcciones.</p>
<p>Por último, aunque las pruebas fueron unidireccionales, vale la pena mencionar que FEC puede aplicarse de forma independiente en cada dirección. Esto significa que, con una implementación bien ajustada, se podría tolerar cerca de un 5% de pérdida de paquetes por dirección sin afectar significativamente el rendimiento.</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>Forward Error Correction (FEC) es una técnica proactiva que agrega redundancia antes de la transmisión de paquetes, permitiendo que el receptor recupere ciertas pérdidas sin necesidad de retransmisiones. Esto la hace especialmente valiosa para aplicaciones en tiempo real como voz o video, donde esperar retransmisiones generaría retrasos perjudiciales.</p>
<p>Recuerda que habilitar FEC viene con un costo: introduce carga adicional. El edge de SD-WAN que recibe los paquetes necesita usar capacidad de procesamiento adicional para reconstruir los que se perdieron. Por eso, es recomendable activarlo solo para tráfico crítico y, en lo posible, hacerlo condicionado a un <em>threshold</em> de pérdida de paquetes.</p>
<p>FEC no reemplaza la necesidad de corregir enlaces de red defectuosos. Más bien, actúa como una capa de mitigación inteligente que ayuda a suavizar pérdidas moderadas o transitorias, manteniendo una experiencia de usuario consistente incluso cuando la red no es perfecta.</p>
<p>En resumen, cuando se implementa correctamente, FEC puede ser una herramienta muy poderosa en tu arquitectura SD-WAN, ayudando a garantizar un rendimiento de aplicaciones constante sobre redes imperfectas.</p>
<p>💭 ¿Qué opinas sobre el uso de Forward Error Correction en SD-WAN? ¿Lo has utilizado antes? ¿Tienes dudas sobre cómo funciona o cuándo activarlo?</p>
<p>Déjame tus comentarios, preguntas o experiencias. Me encantaría saber cómo están abordando esta función en sus despliegues reales.
¡Aprendamos entre todos!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer><script src="https://utteranc.es/client.js"
        repo="aruiz-p/netwithalex"
        issue-term="title"
        label="comments"
        theme="preferred-color-scheme"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/es/">NetWithAlex</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copiar';

        function copyingDone() {
            copybutton.innerHTML = '¡copiado!';
            setTimeout(() => {
                copybutton.innerHTML = 'copiar';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
