<!DOCTYPE html>
<html lang="es" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Serie AppQoe: Forward Error Correction (FEC) | NetWithAlex</title>
<meta name="keywords" content="">
<meta name="description" content="Aprende c√≥mo funciona Forward Error Correction (FEC) en Cisco SD-WAN para mejorar el rendimiento de las aplicaciones en enlaces con p√©rdida de paquetes. Explora casos de uso, configuraci√≥n y resultados de pruebas.">
<meta name="author" content="Alex">
<link rel="canonical" href="http://localhost:1313/appqoe-fec/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/assets/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/appqoe-fec/">
<link rel="alternate" hreflang="es" href="http://localhost:1313/appqoe-fec/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>















    
        <link rel="preconnect" href="https://plausible.io">
    
        <!-- Dev mode : We do not load plausible script to avoid bloating your stats -->

<!-- If you are using Content-Security-Policy, do not forget to add this code to your CSP : 
  script-src 'unsafe-inline' https://plausible.io
  connect-src 'unsafe-inline' https://plausible.io
  or just add the partial 'plausible_csp.html' to those 2 csp directives in your 'index.headers' file
-->



    
    <script>window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }</script>
    <script>
         
         
         
    </script>

    
<meta property="og:url" content="http://localhost:1313/appqoe-fec/">
  <meta property="og:site_name" content="NetWithAlex">
  <meta property="og:title" content="Serie AppQoe: Forward Error Correction (FEC)">
  <meta property="og:description" content="Aprende c√≥mo funciona Forward Error Correction (FEC) en Cisco SD-WAN para mejorar el rendimiento de las aplicaciones en enlaces con p√©rdida de paquetes. Explora casos de uso, configuraci√≥n y resultados de pruebas.">
  <meta property="og:locale" content="es">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-05-19T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-05-19T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Serie AppQoe: Forward Error Correction (FEC)">
<meta name="twitter:description" content="Aprende c√≥mo funciona Forward Error Correction (FEC) en Cisco SD-WAN para mejorar el rendimiento de las aplicaciones en enlaces con p√©rdida de paquetes. Explora casos de uso, configuraci√≥n y resultados de pruebas.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/es/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Serie AppQoe: Forward Error Correction (FEC)",
      "item": "http://localhost:1313/appqoe-fec/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Serie AppQoe: Forward Error Correction (FEC)",
  "name": "Serie AppQoe: Forward Error Correction (FEC)",
  "description": "Aprende c√≥mo funciona Forward Error Correction (FEC) en Cisco SD-WAN para mejorar el rendimiento de las aplicaciones en enlaces con p√©rdida de paquetes. Explora casos de uso, configuraci√≥n y resultados de pruebas.",
  "keywords": [
    
  ],
  "articleBody": "Introducci√≥n Ofrecer un rendimiento de aplicaci√≥n consistente sobre enlaces congestionados o poco confiables es un desaf√≠o constante para la mayor√≠a de las redes. Incluso con funciones avanzadas como Enhanced Application-Aware Routing u Optimizaci√≥n TCP, hay condiciones en los enlaces que van m√°s all√° de lo que el failover, el balanceo de carga o la optimizaci√≥n pueden resolver.\nAl agregar un mecanismo de recuperaci√≥n a nivel de paquete, FEC permite que Cisco SD-WAN enmascare la p√©rdida de paquetes y mantenga el rendimiento de las aplicaciones sin depender de retransmisiones.\nEn este post, exploraremos qu√© tan efectivo puede ser FEC en un entorno SD-WAN, simulando condiciones con p√©rdida de paquetes y midiendo las tasas de recuperaci√≥n.\nSi est√°s evaluando FEC para tu despliegue o simplemente tienes curiosidad sobre c√≥mo funciona, este art√≠culo te llevar√° por la teor√≠a y la pr√°ctica.\nVamos all√°!\nQu√© es Forward Error Correction (FEC)? Forward Error Correction (FEC) es una t√©cnica que mejora la confiabilidad de la transmisi√≥n de datos a√±adiendo informaci√≥n redundante a los paquetes antes de enviarlos por la red. En lugar de esperar retransmisiones cuando se pierden paquetes, el receptor utiliza esa redundancia para reconstruir los datos faltantes en tiempo real.\nEn la implementaci√≥n de Cisco SD-WAN, FEC agrupa 4 paquetes de datos y agrega 1 paquete de paridad. Si uno de esos 4 paquetes se pierde en el camino, el receptor puede reconstruirlo utilizando el paquete de paridad mediante una operaci√≥n XOR.\nVe√°moslo en un diagrama:\nEl remitente transmite la informaci√≥n al receptor, pero el paquete 3 se pierde en tr√°nsito. El receptor puede usar el paquete de paridad para reconstruir el paquete 3 y as√≠ evitar retransmisiones y retrasos que afectar√≠an la experiencia de las aplicaciones.\nEs importante notar que si se pierden m√°s de 1 paquete, incluyendo el de paridad, no es posible reconstruir la informaci√≥n. El tama√±o del bloque es siempre de 4 paquetes de datos + 1 de paridad y no puede modificarse. Un bloque puede contener paquetes de diferentes flujos.\nNota El hecho de que FEC agregue 1 paquete de paridad por cada bloque de 4 incrementa el consumo de ancho de banda.\nHay dos modos de operaci√≥n:\nAlways: Se aplica FEC a todo el tr√°fico que haga match a la pol√≠tica, sin importar la cantidad de p√©rdida de paquetes en el transporte. Adaptive: Permite definir un threshold de p√©rdida de paquetes antes de empezar a aplicar FEC. Por ejemplo, si hay 2% o m√°s p√©rdida de paquetes, se debe aplicar FEC al tr√°fico. El porcentaje de p√©rdida de paquetes se saca con los paquetes BFD. FEC es especialmente √∫til en aplicaciones en tiempo real como voz, video o sesiones interactivas, donde esperar retransmisiones provocar√≠a retrasos severos.\nUn punto importante es que FEC opera entre los dispositivos edge de SD-WAN, lo que lo hace completamente transparente para las aplicaciones: no es necesario modificar el comportamiento de clientes o servidores. Sin embargo, solo funciona cuando se utiliza encapsulaci√≥n IPSec; no est√° soportado sobre t√∫neles GRE.\nUn detalle cr√≠tico de implementaci√≥n es el tama√±o de los paquetes: si los paquetes son demasiado grandes y terminan siendo fragmentados, la capacidad de FEC para reconstruirlos se reduce considerablemente. Para aprovechar al m√°ximo FEC, aseg√∫rate de que el payload se mantenga por debajo del MTU del path MTU para evitar la fragmentaci√≥n.\nConfiguraci√≥n Utilizando Policy Groups, podemos configurar FEC a trav√©s de pol√≠tica de datos que hagan match al tr√°fico y apliquen la acci√≥n Loss Correction\nEn mi caso, hice match a a todo el tr√°fico entre 172.16.10.0/24 y 172.16.100.0/24. Nota que se tienen los dos modos de operaci√≥n: Always y Adaptive\nSi se selecciona FEC Adaptive, el threshold tiene que estar entre 1% y 5% p√©rdida de paquetes.\nEst√° es la configuraci√≥n completa de mi pol√≠tica:\nvsmart_1# show running-config policy policy data-policy data_all_FEC vpn-list vpn_Corporate_Users sequence 1 match source-ip 172.16.100.0/24 destination-ip 172.16.10.0/24 ! action accept loss-protect fec-always loss-protection forward-error-correction always ! ! sequence 11 match source-ip 172.16.10.0/24 destination-ip 172.16.100.0/24 ! action accept loss-protect fec-always loss-protection forward-error-correction always ! ! default-action accept ! ! lists vpn-list vpn_Corporate_Users vpn 10 ! site-list site_10_100 site-id 10 site-id 100 ! ! apply-policy site-list site_10_100 data-policy data_all_FEC from-service ! ! ! Verificaci√≥n de FEC No hay muchos comandos relacionados a FEC, pero podemos confirmar que FEC est√° operando con el siguiente comando:\nMunich_DC100-1#show sdwan tunnel statistics fec tunnel stats ipsec 21.101.0.2 21.11.0.2 12346 12346 fec-rx-data-pkts 16243 fec-rx-parity-pkts 4075 fec-tx-data-pkts 7 fec-tx-parity-pkts 1 fec-reconstruct-pkts 935 fec-capable true fec-dynamic false El fec-reconstruct-pkts indica que se recuperaron 935 paquetes\nNota tambi√©n que podemos f√°cilmente ver la cantidad de paquetes de paridad que se enviaron y recibieron siendo aproximadamente 1/4 del total de paquetes de datos enviados/recibidos.\nLa misma informaci√≥n est√° tambi√©n disponible a trav√©s de la interfaz gr√°fica del Manager, en la opci√≥n de real time\nProbando FEC A bandwidth of 450k is around 5 VoIP calls and using a payload of 361 bytes.\nIn this case, I am running unidirectional tests, but keep in mind FEC works in both directions.\nVamos a realizar algunas pruebas para ver FEC en acci√≥n y analizar la cantidad de p√©rdida de paquetes que puede recuperar. Mostrar√© distintos resultados para entender en qu√© condiciones FEC ofrece mejores beneficios.\nNota existe cierta p√©rdida de paquetes fuera de los routers SD-WAN que no puedo controlar. Por eso, para obtener resultados m√°s precisos, primero tuve que encontrar una tasa de transmisi√≥n con la que obtuviera 0% de p√©rdida la mayor parte del tiempo en mis resultados con iperf3, y a partir de ah√≠ comenc√© a introducir p√©rdida de manera controlada.\niperf -c 172.16.100.11 -u -b 450k -t 30 -l 361 ‚Äìdscp ef\nUn ancho de banda de 450 kbps equivale aproximadamente a 5 llamadas VoIP, utilizando un payload de 361 bytes.\nEn este caso, estoy realizando pruebas unidireccionales, pero ten en cuenta que FEC funciona en ambos sentidos.\n% P√©rdida Total Paquetes enviados Total Paquetes recibidos Paquetes recuperados % efectivo de p√©rdida 1 4693 4639 54 0 2 4694 4588 96 0,24 3 4693 4558 111 0,58 4 4694 4524 147 0,51 5 4693 4448 195 0,68 6 4693 4401 231 1,3 7 4693 4374 238 1,8 8 4693 4331 283 1,8 9 4693 4292 297 2,2 10 4693 4215 304 3,8 12 4693 4122 348 3,8 15 4695 3941 382 8 18 4696 3815 356 11 20 4696 3731 368 13 Veamos unas gr√°ficas interesantes:\nA medida que aumenta la p√©rdida de paquetes, tambi√©n crece el n√∫mero de paquetes recuperados, hasta cierto punto. Esto es esperable: FEC agrega redundancia, y cuanto m√°s se pierde, m√°s se necesita recuperar. Sin embargo, esta capacidad tiene un l√≠mite natural: si se pierden dos o m√°s paquetes dentro del mismo bloque FEC ‚Äîincluyendo el paquete de paridad‚Äî la recuperaci√≥n ya no es posible y la p√©rdida efectiva comienza a aumentar.\nTambi√©n es importante destacar que FEC es una funci√≥n utiliza muchos recursos, por lo que se recomienda activarla solo para tr√°fico cr√≠tico y, preferentemente, en combinaci√≥n con un threshold de p√©rdida de paquetes, en lugar de mantenerla activa permanentemente.\nAunque este laboratorio no replica a la perfecci√≥n un entorno de producci√≥n, los resultados son bastante reveladores. FEC logr√≥ recuperar pr√°cticamente todos los paquetes perdidos con hasta un 5% de p√©rdida introducida, y continu√≥ recuperando cerca del 70% de los paquetes a aproximadamente 9% de p√©rdida. A partir de ah√≠, la eficiencia de recuperaci√≥n empieza a disminuir. Dicho esto, no es com√∫n ver p√©rdidas constantes superiores al 10% en enlaces WAN de producci√≥n, y menos a√∫n en ambas direcciones.\nPor √∫ltimo, aunque las pruebas fueron unidireccionales, vale la pena mencionar que FEC puede aplicarse de forma independiente en cada direcci√≥n. Esto significa que, con una implementaci√≥n bien ajustada, se podr√≠a tolerar cerca de un 5% de p√©rdida de paquetes por direcci√≥n sin afectar significativamente el rendimiento.\nConclusion Forward Error Correction (FEC) es una t√©cnica proactiva que agrega redundancia antes de la transmisi√≥n de paquetes, permitiendo que el receptor recupere ciertas p√©rdidas sin necesidad de retransmisiones. Esto la hace especialmente valiosa para aplicaciones en tiempo real como voz o video, donde esperar retransmisiones generar√≠a retrasos perjudiciales.\nRecuerda que habilitar FEC viene con un costo: introduce carga adicional. El edge de SD-WAN que recibe los paquetes necesita usar capacidad de procesamiento adicional para reconstruir los que se perdieron. Por eso, es recomendable activarlo solo para tr√°fico cr√≠tico y, en lo posible, hacerlo condicionado a un threshold de p√©rdida de paquetes.\nFEC no reemplaza la necesidad de corregir enlaces de red defectuosos. M√°s bien, act√∫a como una capa de mitigaci√≥n inteligente que ayuda a suavizar p√©rdidas moderadas o transitorias, manteniendo una experiencia de usuario consistente incluso cuando la red no es perfecta.\nEn resumen, cuando se implementa correctamente, FEC puede ser una herramienta muy poderosa en tu arquitectura SD-WAN, ayudando a garantizar un rendimiento de aplicaciones constante sobre redes imperfectas.\nüí≠ ¬øQu√© opinas sobre el uso de Forward Error Correction en SD-WAN? ¬øLo has utilizado antes? ¬øTienes dudas sobre c√≥mo funciona o cu√°ndo activarlo?\nD√©jame tus comentarios, preguntas o experiencias. Me encantar√≠a saber c√≥mo est√°n abordando esta funci√≥n en sus despliegues reales. ¬°Aprendamos entre todos!\n",
  "wordCount" : "1510",
  "inLanguage": "es",
  "datePublished": "2025-05-19T00:00:00Z",
  "dateModified": "2025-05-19T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Alex"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/appqoe-fec/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "NetWithAlex",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/assets/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/es/" accesskey="h" title="NetWithAlex (Alt + H)">NetWithAlex</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://localhost:1313/" title="English"
                            aria-label="English">En</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/es/" title="Inicio">
                    <span>Inicio</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/archives/" title="Archivo">
                    <span>Archivo</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/category/" title="Categor√≠as">
                    <span>Categor√≠as</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/sobre-mi/" title="Sobre m√≠">
                    <span>Sobre m√≠</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/search/" title="üîç">
                    <span>üîç</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/es/">Inicio</a>&nbsp;¬ª&nbsp;<a href="http://localhost:1313/es/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Serie AppQoe: Forward Error Correction (FEC)
    </h1>
    <div class="post-description">
      Aprende c√≥mo funciona Forward Error Correction (FEC) en Cisco SD-WAN para mejorar el rendimiento de las aplicaciones en enlaces con p√©rdida de paquetes. Explora casos de uso, configuraci√≥n y resultados de pruebas.
    </div>
    <div class="post-meta"><span title='2025-05-19 00:00:00 +0000 +0000'>mayo 19, 2025</span>&nbsp;¬∑&nbsp;8 min&nbsp;¬∑&nbsp;Alex&nbsp;|&nbsp;Traducciones:
<ul class="i18n_list">
    <li>
        <a href="http://localhost:1313/appqoe-fec/">En</a>
    </li>
</ul>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Tabla de Contenidos</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introducci%c3%b3n" aria-label="Introducci√≥n">Introducci√≥n</a></li>
                <li>
                    <a href="#qu%c3%a9-es-forward-error-correction-fec" aria-label="Qu√© es Forward Error Correction (FEC)?">Qu√© es Forward Error Correction (FEC)?</a></li>
                <li>
                    <a href="#configuraci%c3%b3n" aria-label="Configuraci√≥n">Configuraci√≥n</a></li>
                <li>
                    <a href="#verificaci%c3%b3n-de-fec" aria-label="Verificaci√≥n de FEC">Verificaci√≥n de FEC</a></li>
                <li>
                    <a href="#probando-fec" aria-label="Probando FEC">Probando FEC</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="introducci√≥n">Introducci√≥n<a hidden class="anchor" aria-hidden="true" href="#introducci√≥n">#</a></h2>
<p>Ofrecer un rendimiento de aplicaci√≥n consistente sobre enlaces congestionados o poco confiables es un desaf√≠o constante para la mayor√≠a de las redes. Incluso con funciones avanzadas como <a href="/aar-mejorado/">Enhanced Application-Aware Routing</a> u <a href="/appqoe-opt-tcp/">Optimizaci√≥n TCP</a>, hay condiciones en los enlaces que van m√°s all√° de lo que el failover, el balanceo de carga o la optimizaci√≥n pueden resolver.</p>
<p>Al agregar un mecanismo de recuperaci√≥n a nivel de paquete, FEC permite que Cisco SD-WAN enmascare la p√©rdida de paquetes y mantenga el rendimiento de las aplicaciones sin depender de retransmisiones.</p>
<p>En este post, exploraremos qu√© tan efectivo puede ser FEC en un entorno SD-WAN, simulando condiciones con p√©rdida de paquetes y midiendo las tasas de recuperaci√≥n.</p>
<p>Si est√°s evaluando FEC para tu despliegue o simplemente tienes curiosidad sobre c√≥mo funciona, este art√≠culo te llevar√° por la teor√≠a y la pr√°ctica.</p>
<p>Vamos all√°!</p>
<h2 id="qu√©-es-forward-error-correction-fec">Qu√© es Forward Error Correction (FEC)?<a hidden class="anchor" aria-hidden="true" href="#qu√©-es-forward-error-correction-fec">#</a></h2>
<p>Forward Error Correction (FEC) es una t√©cnica que mejora la confiabilidad de la transmisi√≥n de datos a√±adiendo informaci√≥n redundante a los paquetes antes de enviarlos por la red. En lugar de esperar retransmisiones cuando se pierden paquetes, el receptor utiliza esa redundancia para reconstruir los datos faltantes en tiempo real.</p>
<p>En la implementaci√≥n de Cisco SD-WAN, FEC agrupa 4 paquetes de datos y agrega 1 <em>paquete de paridad</em>. Si <strong>uno</strong> de esos 4 paquetes se pierde en el camino, el receptor puede reconstruirlo utilizando el paquete de paridad mediante una operaci√≥n XOR.</p>
<p>Ve√°moslo en un diagrama:</p>
<p><img loading="lazy" src="/wp-content/uploads/2025/05/fec1.png"></p>
<p>El remitente transmite la informaci√≥n al receptor, pero el paquete 3 se pierde en tr√°nsito. El receptor puede usar el paquete de paridad para reconstruir el paquete 3 y as√≠ evitar retransmisiones y retrasos que afectar√≠an la experiencia de las aplicaciones.</p>
<p>Es importante notar que si se pierden m√°s de 1 paquete, incluyendo el de paridad, no es posible reconstruir la informaci√≥n. El tama√±o del bloque es siempre de 4 paquetes de datos + 1 de paridad y no puede modificarse. Un bloque puede contener paquetes de diferentes flujos.</p>
<blockquote>
<p><strong>Nota</strong> El hecho de que FEC agregue 1 paquete de paridad por cada bloque de 4 incrementa el consumo de ancho de banda.</p>
</blockquote>
<p>Hay dos modos de operaci√≥n:</p>
<ul>
<li><strong>Always</strong>: Se aplica FEC a todo el tr√°fico que haga match a la pol√≠tica, sin importar la cantidad de p√©rdida de paquetes en el transporte.</li>
<li><strong>Adaptive</strong>: Permite definir un <em>threshold</em> de p√©rdida de paquetes antes de empezar a aplicar FEC. Por ejemplo, si hay 2% o m√°s p√©rdida de paquetes, se debe aplicar FEC al tr√°fico. El porcentaje de p√©rdida de paquetes se saca con los <a href="/simplificando-aar-1-3-las-bases/#bfd/">paquetes BFD</a>.</li>
</ul>
<p>FEC es especialmente √∫til en aplicaciones en tiempo real como voz, video o sesiones interactivas, donde esperar retransmisiones provocar√≠a retrasos severos.</p>
<p>Un punto importante es que FEC opera entre los dispositivos edge de SD-WAN, lo que lo hace completamente transparente para las aplicaciones: no es necesario modificar el comportamiento de clientes o servidores. Sin embargo, solo funciona cuando se utiliza encapsulaci√≥n IPSec; <strong>no est√° soportado sobre t√∫neles GRE.</strong></p>
<p>Un detalle cr√≠tico de implementaci√≥n es el tama√±o de los paquetes: si los paquetes son demasiado grandes y terminan siendo fragmentados, la capacidad de FEC para reconstruirlos se reduce considerablemente. Para aprovechar al m√°ximo FEC, aseg√∫rate de que el <em>payload</em> se mantenga por debajo del MTU del <em>path MTU</em> para evitar la fragmentaci√≥n.</p>
<h2 id="configuraci√≥n">Configuraci√≥n<a hidden class="anchor" aria-hidden="true" href="#configuraci√≥n">#</a></h2>
<p>Utilizando <em>Policy Groups</em>, podemos configurar FEC a trav√©s de pol√≠tica de datos que hagan match al tr√°fico y apliquen la acci√≥n <em>Loss Correction</em></p>
<p><img loading="lazy" src="/wp-content/uploads/2025/05/fec2.png"></p>
<p>En mi caso, hice match a a todo el tr√°fico entre 172.16.10.0/24 y 172.16.100.0/24. Nota que se tienen los dos modos de operaci√≥n: <em>Always y Adaptive</em></p>
<p>Si se selecciona FEC Adaptive, el <em>threshold</em> tiene que estar entre 1% y 5% p√©rdida de paquetes.</p>
<p>Est√° es la configuraci√≥n completa de mi pol√≠tica:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>vsmart_1# show running-config policy 
</span></span><span style="display:flex;"><span>policy
</span></span><span style="display:flex;"><span> data-policy data_all_FEC
</span></span><span style="display:flex;"><span>  vpn-list vpn_Corporate_Users
</span></span><span style="display:flex;"><span>   sequence 1
</span></span><span style="display:flex;"><span>    match
</span></span><span style="display:flex;"><span>     source-ip      172.16.100.0/24
</span></span><span style="display:flex;"><span>     destination-ip 172.16.10.0/24
</span></span><span style="display:flex;"><span>    !
</span></span><span style="display:flex;"><span>    action accept
</span></span><span style="display:flex;"><span>     loss-protect fec-always
</span></span><span style="display:flex;"><span>     loss-protection forward-error-correction always
</span></span><span style="display:flex;"><span>    !
</span></span><span style="display:flex;"><span>   !
</span></span><span style="display:flex;"><span>   sequence 11
</span></span><span style="display:flex;"><span>    match
</span></span><span style="display:flex;"><span>     source-ip      172.16.10.0/24
</span></span><span style="display:flex;"><span>     destination-ip 172.16.100.0/24
</span></span><span style="display:flex;"><span>    !
</span></span><span style="display:flex;"><span>    action accept
</span></span><span style="display:flex;"><span>     loss-protect fec-always
</span></span><span style="display:flex;"><span>     loss-protection forward-error-correction always
</span></span><span style="display:flex;"><span>    !
</span></span><span style="display:flex;"><span>   !
</span></span><span style="display:flex;"><span>   default-action accept
</span></span><span style="display:flex;"><span>  !
</span></span><span style="display:flex;"><span> !
</span></span><span style="display:flex;"><span> lists
</span></span><span style="display:flex;"><span>  vpn-list vpn_Corporate_Users
</span></span><span style="display:flex;"><span>   vpn 10
</span></span><span style="display:flex;"><span>  !
</span></span><span style="display:flex;"><span>  site-list site_10_100
</span></span><span style="display:flex;"><span>   site-id 10
</span></span><span style="display:flex;"><span>   site-id 100
</span></span><span style="display:flex;"><span>  !
</span></span><span style="display:flex;"><span> !
</span></span><span style="display:flex;"><span> apply-policy
</span></span><span style="display:flex;"><span> site-list site_10_100
</span></span><span style="display:flex;"><span>  data-policy data_all_FEC from-service
</span></span><span style="display:flex;"><span> !
</span></span><span style="display:flex;"><span>!
</span></span><span style="display:flex;"><span>!
</span></span></code></pre></div><h2 id="verificaci√≥n-de-fec">Verificaci√≥n de FEC<a hidden class="anchor" aria-hidden="true" href="#verificaci√≥n-de-fec">#</a></h2>
<p>No hay muchos comandos relacionados a FEC, pero podemos confirmar que FEC est√° operando con el siguiente comando:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gdscript3" data-lang="gdscript3"><span style="display:flex;"><span>Munich_DC100<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#75715e">#show sdwan tunnel statistics fec </span>
</span></span><span style="display:flex;"><span>tunnel stats ipsec <span style="color:#ae81ff">21.101</span><span style="color:#f92672">.</span><span style="color:#ae81ff">0.2</span> <span style="color:#ae81ff">21.11</span><span style="color:#f92672">.</span><span style="color:#ae81ff">0.2</span> <span style="color:#ae81ff">12346</span> <span style="color:#ae81ff">12346</span>
</span></span><span style="display:flex;"><span> fec<span style="color:#f92672">-</span>rx<span style="color:#f92672">-</span>data<span style="color:#f92672">-</span>pkts     <span style="color:#ae81ff">16243</span>
</span></span><span style="display:flex;"><span> fec<span style="color:#f92672">-</span>rx<span style="color:#f92672">-</span>parity<span style="color:#f92672">-</span>pkts   <span style="color:#ae81ff">4075</span>
</span></span><span style="display:flex;"><span> fec<span style="color:#f92672">-</span>tx<span style="color:#f92672">-</span>data<span style="color:#f92672">-</span>pkts     <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span> fec<span style="color:#f92672">-</span>tx<span style="color:#f92672">-</span>parity<span style="color:#f92672">-</span>pkts   <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> fec<span style="color:#f92672">-</span>reconstruct<span style="color:#f92672">-</span>pkts <span style="color:#ae81ff">935</span>
</span></span><span style="display:flex;"><span> fec<span style="color:#f92672">-</span>capable          true
</span></span><span style="display:flex;"><span> fec<span style="color:#f92672">-</span>dynamic          false
</span></span></code></pre></div><p>El <em>fec-reconstruct-pkts</em> indica que se recuperaron 935 paquetes</p>
<p>Nota tambi√©n que podemos f√°cilmente ver la cantidad de paquetes de paridad que se enviaron y recibieron siendo aproximadamente 1/4 del total de paquetes de datos enviados/recibidos.</p>
<p>La misma informaci√≥n est√° tambi√©n disponible a trav√©s de la interfaz gr√°fica del Manager, en la opci√≥n de <em>real time</em></p>
<p><img loading="lazy" src="/wp-content/uploads/2025/05/fec3.png"></p>
<h2 id="probando-fec">Probando FEC<a hidden class="anchor" aria-hidden="true" href="#probando-fec">#</a></h2>
<p>A bandwidth of 450k is <strong>around</strong> 5 VoIP calls and using a payload of 361 bytes.</p>
<p>In this case, I am running unidirectional tests, but keep in mind FEC works in both directions.</p>
<p>Vamos a realizar algunas pruebas para ver FEC en acci√≥n y analizar la cantidad de p√©rdida de paquetes que puede recuperar. Mostrar√© distintos resultados para entender en qu√© condiciones FEC ofrece mejores beneficios.</p>
<p><strong>Nota</strong> existe cierta p√©rdida de paquetes fuera de los routers SD-WAN que no puedo controlar. Por eso, para obtener resultados m√°s precisos, primero tuve que encontrar una tasa de transmisi√≥n con la que obtuviera 0% de p√©rdida la <strong>mayor parte del tiempo</strong> en mis resultados con iperf3, y a partir de ah√≠ comenc√© a introducir p√©rdida de manera controlada.</p>
<blockquote>
<p>iperf -c 172.16.100.11 -u -b 450k -t 30 -l 361 &ndash;dscp ef</p>
</blockquote>
<p>Un ancho de banda de 450 kbps equivale aproximadamente a 5 llamadas VoIP, utilizando un <em>payload</em> de 361 bytes.</p>
<p>En este caso, estoy realizando pruebas unidireccionales, pero ten en cuenta que FEC funciona en ambos sentidos.</p>
<table>
  <thead>
      <tr>
          <th>% P√©rdida</th>
          <th>Total Paquetes enviados</th>
          <th>Total Paquetes recibidos</th>
          <th>Paquetes recuperados</th>
          <th>% efectivo de p√©rdida</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>4693</td>
          <td>4639</td>
          <td>54</td>
          <td>0</td>
      </tr>
      <tr>
          <td>2</td>
          <td>4694</td>
          <td>4588</td>
          <td>96</td>
          <td>0,24</td>
      </tr>
      <tr>
          <td>3</td>
          <td>4693</td>
          <td>4558</td>
          <td>111</td>
          <td>0,58</td>
      </tr>
      <tr>
          <td>4</td>
          <td>4694</td>
          <td>4524</td>
          <td>147</td>
          <td>0,51</td>
      </tr>
      <tr>
          <td>5</td>
          <td>4693</td>
          <td>4448</td>
          <td>195</td>
          <td>0,68</td>
      </tr>
      <tr>
          <td>6</td>
          <td>4693</td>
          <td>4401</td>
          <td>231</td>
          <td>1,3</td>
      </tr>
      <tr>
          <td>7</td>
          <td>4693</td>
          <td>4374</td>
          <td>238</td>
          <td>1,8</td>
      </tr>
      <tr>
          <td>8</td>
          <td>4693</td>
          <td>4331</td>
          <td>283</td>
          <td>1,8</td>
      </tr>
      <tr>
          <td>9</td>
          <td>4693</td>
          <td>4292</td>
          <td>297</td>
          <td>2,2</td>
      </tr>
      <tr>
          <td>10</td>
          <td>4693</td>
          <td>4215</td>
          <td>304</td>
          <td>3,8</td>
      </tr>
      <tr>
          <td>12</td>
          <td>4693</td>
          <td>4122</td>
          <td>348</td>
          <td>3,8</td>
      </tr>
      <tr>
          <td>15</td>
          <td>4695</td>
          <td>3941</td>
          <td>382</td>
          <td>8</td>
      </tr>
      <tr>
          <td>18</td>
          <td>4696</td>
          <td>3815</td>
          <td>356</td>
          <td>11</td>
      </tr>
      <tr>
          <td>20</td>
          <td>4696</td>
          <td>3731</td>
          <td>368</td>
          <td>13</td>
      </tr>
  </tbody>
</table>
<p>Veamos unas gr√°ficas interesantes:</p>
<p><img loading="lazy" src="/wp-content/uploads/2025/05/fec4.png">
<img loading="lazy" src="/wp-content/uploads/2025/05/fec5.png">
<img loading="lazy" src="/wp-content/uploads/2025/05/fec6.png"></p>
<p>A medida que aumenta la p√©rdida de paquetes, tambi√©n crece el n√∫mero de paquetes recuperados, hasta cierto punto. Esto es esperable: FEC agrega redundancia, y cuanto m√°s se pierde, m√°s se necesita recuperar. Sin embargo, esta capacidad tiene un l√≠mite natural: si se pierden dos o m√°s paquetes dentro del mismo bloque FEC ‚Äîincluyendo el paquete de paridad‚Äî la recuperaci√≥n ya no es posible y la p√©rdida efectiva comienza a aumentar.</p>
<p>Tambi√©n es importante destacar que FEC es una funci√≥n <strong>utiliza muchos recursos</strong>, por lo que se recomienda activarla solo para tr√°fico cr√≠tico y, preferentemente, en combinaci√≥n con un <em>threshold</em> de p√©rdida de paquetes, en lugar de mantenerla activa permanentemente.</p>
<p>Aunque este laboratorio no replica a la perfecci√≥n un entorno de producci√≥n, los resultados son bastante reveladores. FEC logr√≥ recuperar pr√°cticamente todos los paquetes perdidos con hasta un 5% de p√©rdida introducida, y continu√≥ recuperando cerca del 70% de los paquetes a aproximadamente 9% de p√©rdida. A partir de ah√≠, la eficiencia de recuperaci√≥n empieza a disminuir. Dicho esto, no es com√∫n ver p√©rdidas constantes superiores al 10% en enlaces WAN de producci√≥n, y menos a√∫n en ambas direcciones.</p>
<p>Por √∫ltimo, aunque las pruebas fueron unidireccionales, vale la pena mencionar que FEC puede aplicarse de forma independiente en cada direcci√≥n. Esto significa que, con una implementaci√≥n bien ajustada, se podr√≠a tolerar cerca de un 5% de p√©rdida de paquetes por direcci√≥n sin afectar significativamente el rendimiento.</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>Forward Error Correction (FEC) es una t√©cnica proactiva que agrega redundancia antes de la transmisi√≥n de paquetes, permitiendo que el receptor recupere ciertas p√©rdidas sin necesidad de retransmisiones. Esto la hace especialmente valiosa para aplicaciones en tiempo real como voz o video, donde esperar retransmisiones generar√≠a retrasos perjudiciales.</p>
<p>Recuerda que habilitar FEC viene con un costo: introduce carga adicional. El edge de SD-WAN que recibe los paquetes necesita usar capacidad de procesamiento adicional para reconstruir los que se perdieron. Por eso, es recomendable activarlo solo para tr√°fico cr√≠tico y, en lo posible, hacerlo condicionado a un <em>threshold</em> de p√©rdida de paquetes.</p>
<p>FEC no reemplaza la necesidad de corregir enlaces de red defectuosos. M√°s bien, act√∫a como una capa de mitigaci√≥n inteligente que ayuda a suavizar p√©rdidas moderadas o transitorias, manteniendo una experiencia de usuario consistente incluso cuando la red no es perfecta.</p>
<p>En resumen, cuando se implementa correctamente, FEC puede ser una herramienta muy poderosa en tu arquitectura SD-WAN, ayudando a garantizar un rendimiento de aplicaciones constante sobre redes imperfectas.</p>
<p>üí≠ ¬øQu√© opinas sobre el uso de Forward Error Correction en SD-WAN? ¬øLo has utilizado antes? ¬øTienes dudas sobre c√≥mo funciona o cu√°ndo activarlo?</p>
<p>D√©jame tus comentarios, preguntas o experiencias. Me encantar√≠a saber c√≥mo est√°n abordando esta funci√≥n en sus despliegues reales.
¬°Aprendamos entre todos!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer><script src="https://utteranc.es/client.js"
        repo="aruiz-p/netwithalex"
        issue-term="title"
        label="comments"
        theme="preferred-color-scheme"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/es/">NetWithAlex</a></span> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copiar';

        function copyingDone() {
            copybutton.innerHTML = '¬°copiado!';
            setTimeout(() => {
                copybutton.innerHTML = 'copiar';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
