<!DOCTYPE html>
<html lang="es" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>NetWithAlex</title>
<meta name="keywords" content="">
<meta name="description" content="Introducción
Ha pasado un tiempo desde que quería subirme al tren LLM y aprender a usar uno de los marcos populares. Hace unos meses, vi una gran presentación [de Cisco Live] (https://www.ciscolive.com/on-demand/on-demand-library.html?search=Jesus&search=jesus#/session/1707505627331001pilj) por mi buen amigo, y me dio la determinación que finalmente me necesitaba para que finalmente dijera el tema.
Desde entonces, he estado investigando y pensando en un buen caso de uso para que pueda poner como objetivo de mi proceso de aprendizaje. Después de considerar diferentes opciones, decidí construir un asistente de IA SD-WAN que podría ayudarme a solucionar problemas de un problema SD-WAN. Aprovechando las herramientas disponibles, decidí que mi asistente sería un experto en la funcionalidad de [/Netwide-Wide-Wide-Path-Insights-An-Introduction/) [Work Buid Rath Insights] (/Network-Wide-Path-Insights-An-Introduction/).">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/edificio-my-primero-sd-wan-ai-asistant-with-langchain%20/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/assets/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/building-my-first-sd-wan-ai-assistant-with-langchain/">
<link rel="alternate" hreflang="es" href="http://localhost:1313/edificio-my-primero-sd-wan-ai-asistant-with-langchain%20/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://localhost:1313/edificio-my-primero-sd-wan-ai-asistant-with-langchain%20/">
  <meta property="og:site_name" content="NetWithAlex">
  <meta property="og:title" content="NetWithAlex">
  <meta property="og:description" content="Introducción Ha pasado un tiempo desde que quería subirme al tren LLM y aprender a usar uno de los marcos populares. Hace unos meses, vi una gran presentación [de Cisco Live] (https://www.ciscolive.com/on-demand/on-demand-library.html?search=Jesus&amp;search=jesus#/session/1707505627331001pilj) por mi buen amigo, y me dio la determinación que finalmente me necesitaba para que finalmente dijera el tema.
Desde entonces, he estado investigando y pensando en un buen caso de uso para que pueda poner como objetivo de mi proceso de aprendizaje. Después de considerar diferentes opciones, decidí construir un asistente de IA SD-WAN que podría ayudarme a solucionar problemas de un problema SD-WAN. Aprovechando las herramientas disponibles, decidí que mi asistente sería un experto en la funcionalidad de [/Netwide-Wide-Wide-Path-Insights-An-Introduction/) [Work Buid Rath Insights] (/Network-Wide-Path-Insights-An-Introduction/).">
  <meta property="og:locale" content="es">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="">
<meta name="twitter:description" content="Introducción
Ha pasado un tiempo desde que quería subirme al tren LLM y aprender a usar uno de los marcos populares. Hace unos meses, vi una gran presentación [de Cisco Live] (https://www.ciscolive.com/on-demand/on-demand-library.html?search=Jesus&search=jesus#/session/1707505627331001pilj) por mi buen amigo, y me dio la determinación que finalmente me necesitaba para que finalmente dijera el tema.
Desde entonces, he estado investigando y pensando en un buen caso de uso para que pueda poner como objetivo de mi proceso de aprendizaje. Después de considerar diferentes opciones, decidí construir un asistente de IA SD-WAN que podría ayudarme a solucionar problemas de un problema SD-WAN. Aprovechando las herramientas disponibles, decidí que mi asistente sería un experto en la funcionalidad de [/Netwide-Wide-Wide-Path-Insights-An-Introduction/) [Work Buid Rath Insights] (/Network-Wide-Path-Insights-An-Introduction/).">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/es/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "http://localhost:1313/edificio-my-primero-sd-wan-ai-asistant-with-langchain%20/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "Introducción Ha pasado un tiempo desde que quería subirme al tren LLM y aprender a usar uno de los marcos populares. Hace unos meses, vi una gran presentación [de Cisco Live] (https://www.ciscolive.com/on-demand/on-demand-library.html?search=Jesus\u0026search=jesus#/session/1707505627331001pilj) por mi buen amigo, y me dio la determinación que finalmente me necesitaba para que finalmente dijera el tema.\nDesde entonces, he estado investigando y pensando en un buen caso de uso para que pueda poner como objetivo de mi proceso de aprendizaje. Después de considerar diferentes opciones, decidí construir un asistente de IA SD-WAN que podría ayudarme a solucionar problemas de un problema SD-WAN. Aprovechando las herramientas disponibles, decidí que mi asistente sería un experto en la funcionalidad de [/Netwide-Wide-Wide-Path-Insights-An-Introduction/) [Work Buid Rath Insights] (/Network-Wide-Path-Insights-An-Introduction/).\n",
  "keywords": [
    
  ],
  "articleBody": "Introducción Ha pasado un tiempo desde que quería subirme al tren LLM y aprender a usar uno de los marcos populares. Hace unos meses, vi una gran presentación [de Cisco Live] (https://www.ciscolive.com/on-demand/on-demand-library.html?search=Jesus\u0026search=jesus#/session/1707505627331001pilj) por mi buen amigo, y me dio la determinación que finalmente me necesitaba para que finalmente dijera el tema.\nDesde entonces, he estado investigando y pensando en un buen caso de uso para que pueda poner como objetivo de mi proceso de aprendizaje. Después de considerar diferentes opciones, decidí construir un asistente de IA SD-WAN que podría ayudarme a solucionar problemas de un problema SD-WAN. Aprovechando las herramientas disponibles, decidí que mi asistente sería un experto en la funcionalidad de [/Netwide-Wide-Wide-Path-Insights-An-Introduction/) [Work Buid Rath Insights] (/Network-Wide-Path-Insights-An-Introduction/).\nEn esta publicación, quiero compartir un poco de mi experiencia para construirlo y, por supuesto, mostrar algunos de los resultados. Para una mejor comprensión, sugiero tener el [G] (https://github.com/aruiz-p/sdwan-assistant) [repositorio de iThub] (https://github.com/aruiz-p/sdwan-assistant) se abrió a medida que avanza por la publicación.\nsobre la configuración Mi laboratorio SD-WAN está ejecutando 20.12.3 en el administrador y los bordes WAN están utilizando 17.9.4a. Tengo una topología muy simple que se parece a esto:\n! [] (/wp-content/uploads/2024/07/topology-2.png)\nEl lenguaje de programación utilizado es Python y el marco que elegí interactuar con la LLM es Langchain. Utilicé Operai Model GPT-4O y un BOX BOT para la interacción. El repositorio se puede encontrar [aquí] (https://github.com/aruiz-p/sdwan-assistant).\nmi objetivo En aras del contexto, la resolución de problemas dentro de una tela SD-WAN no es fácil porque el tráfico está encriptado, las políticas dictan cómo fluirá el tráfico, podría haber múltiples rutas a un destino, los próximos lúpulos se pueden cambiar con políticas, hay múltiples lúpulos involucrados y más. Descubrir toda esta información lleva mucho tiempo y no es un proceso sencillo.\n[NWPI] (/Trace de insights-An-Introduction/) de NWPI] es una herramienta que mejora enormemente el proceso de solución de problemas, ya que dará información y visibilidad de lúpulo por hop. Se puede iniciar fácilmente desde la interfaz de usuario del gerente, detectará flujos basados ​​en filtros especificados y puede navegar para obtener toda la visibilidad que necesita. Es una herramienta muy compleja y completa. Como describí antes, quería usar este proyecto como un patio de recreo para aprender y, dado que no tenía experiencia previa con LLMS o Langchain, establecí un objetivo simple:\n_ ** Construye un asistente que pueda iniciar una traza NWPI y darme detalles de los flujos. ** _\nPlanificación y construcción Ok, tenía mi objetivo, pero ¿cómo comenzar?\nTomé un enfoque práctico que significaba que no aprendí a Langchain desde cero y en su lugar tomé el [repositorio de la sesión en vivo de Cisco] (https://github.com/jillesca/cleurdevnet-3707) como base y construida sobre eso. Las razones para elegir este repositorio fueron simples:\nSe explicó en las sesiones, así que tuve una idea general de las tecnologías y su propósito. Pensé que sería fácil ajustar a mi caso de uso (por ejemplo, también uso webex, interactuaré con dispositivos de red, vi cómo las herramientas podrían reemplazarse con la mía) Tuve que limpiar un poco antes de comenzar, esto me requirió que entendiera lo que era esencial para albergar el LLM e interactuar con él. Afortunadamente, el repositorio tenía una estructura organizada que facilitaba la comprensión.\nDe la sesión, aprendí sobre [Langchain Tools] (https://python.langchain.com/v0.1/docs/modules/tools/), así que sabía que podría crear funciones que mi agente podría usar para realizar diferentes acciones. En este caso, las acciones serían algo así como comenzar esos rastros y obtener información de ellos\ndesafío 1 Necesitaba familiarizarme con la API de NWPI, en este punto sabía que había visto en algún lugar de la documentación de la API de que algunas operaciones estaban disponibles, pero nunca me había tomado el tiempo para analizarlas. Para mi sorpresa, las acciones específicas de comenzar un rastro y obtener detalles no se incluyeron … había información sobre cómo comenzar una “tarea” también conocida como “tarea automática”, que no es lo mismo que el “rastro” que tenía en mente. En este punto, necesitaba decidir si iría por la forma “oficial” y tal vez más fácil o explorar una alternativa para lograr exactamente lo que quería.Sabiendo que casi todo está impulsado por API, utilicé la pestaña Inspeccionar de mi navegador y comencé a explorar las API activadas cuando comencé un rastro a través de la interfaz de usuario. Después de un primer pase rápido, determiné que era factible y comencé a recopilar la información que necesitaba.\ndesafío 2 Ya sabía que tendría que hacer un análisis para hacer realidad mi idea, pero subestimé cuánto necesitaría hacer. De hecho, la dificultad de esta tarea me mantuvo alejado del proyecto durante algún tiempo, ya que se volvió cada vez más compleja.\nEn mi mente solo había 3 tareas “simples”:\nEncuentra la API para iniciar el rastro Encuentre la API para confirmar que la traza se está ejecutando Encuentra la API para darme detalles de los flujos Encuentra la API para iniciar el rastro Comenzar un rastro desde la interfaz de usuario es muy simple, solo necesita una ID de sitio y una ID de VPN. Sin embargo, existen verificaciones subyacentes que damos por sentado.\nLa identificación del sitio realmente es necesaria para identificar los dispositivos para iniciar el rastro. Hay un montón de opciones (información de QoS, visibilidad de arte, visibilidad de la aplicación, DIA, etc.) que dependen de la versión. La VPN debe existir. Para hacer esto, creé la función get_device_details_from_site para poder encontrar información relacionada de los dispositivos para iniciar el rastreo. Necesitaba:\nversiones Números de serie nombres Estado de accesibilidad. Luego, creé la función start_trace que recibiría la información obtenida previamente y otros filtros. Mantuve los filtros lo más simples posible, dejando solo una opción para especificar una subred de origen y destino. Hay muchas opciones de rastreo para las que no hice ningún tipo de verificación de versión antes de ejecutarla, solo lo hice para las ideas de QoS que requiere la versión 17.9 o posterior. Esta función devuelve alguna información necesaria más adelante para verificar el estado.\nEncuentra la API para confirmar que la traza se está ejecutando Esta fue probablemente la tarea más fácil. Creé la función verify_trace_state y con la ayuda del LLM se puede ejecutar unos segundos después de comenzar el rastro. Devuelve el estado, que también es necesario para obtener información más adelante.\nEncuentra la API para darme detalles de los flujos Esta fue la tarea más compleja y lenta. En mi mente, verificar el resultado de un rastro es muy simple, sin embargo, cuando recibimos la información en trozos, a través de diferentes llamadas comienza a ser complicada.\nTraté de replicar el proceso que paso en la interfaz de usuario:\nVea las ideas de la traza y verifique los flujos que fueron capturados (si los hubo) Para la lista de flujos, busque el que tuviera el botón de “lectura” en rojo (problema detectado) y haga clic para obtener más detalles. Expanda la vista de flujo para obtener acceso a las funcionalidades avanzadas para que pueda determinar las características que el paquete está pasando en cada uno de los lúpulos. Para capturar los flujos para la traza, creé la función get_flow_summary. Esta función devolverá la lista de flujos capturados, verá detalles como SRC/DST, aplicación y protocolo. Esto es útil para identificar el ID de flujo que le interesa obtener más detalles.\nCreé la función Trace_readout para obtener un resumen de los eventos que la traza capturó junto con la ruta afectada. Por ejemplo, podría ver que un flujo SSH no funciona entre el dispositivo X y el dispositivo Y.\nOk, una vez que haya identificado el flujo y los eventos que le interesan, puede obtener información detallada del flujo con la función get_flow_detail. Esto le dará información de salto de lúpulo como:\nBrincar Evento colores locales/remotos Interfaces de entrada/salida Características de entrada/salida aplicadas a los paquetes Decisión de retención de características Con esta información es posible ver todo tipo de cosas, como ACL, tipo de políticas aplicadas, por qué se enruta un paquete a través de un color específico, cae, confirma que su política funciona como se esperaba, etc.\nOk, creo que eso es todo!\ndemostración Comencé creando un ACL para bloquear la comunicación y la apliqué en el lado de DC.\n`` Munich_DC100-1 - Configuración de ACL\nsdwan interfaz gigabitethernet2 Access-List ACL_DROP_172_16_10_0 OUT\npolítica Access-List ACL_DROP_172_16_10_0 secuencia 1 fósforo Fuente-IP 172.16.10.0/24 Destino-IP 172.16.100.0/24 ! caída de acción conte dropcounter ! ! Aceptación de acción predeterminada !\n``\n¿Mi asistente detectará esto? 🤔\nA continuación, comienzo la aplicación y solicito que el LLM inicie un rastro. Puedo confirmar en la interfaz de usuario que se crea.\n! [] (/WP-Content/uploads/2024/07/starttrace.png)! [] (/wp-content/uploads/2024/07/ui-trace.png)\nEmpiezo un par de conexiones SSH de Branch a DC\n! [] (/wp-content/uploads/2024/07/sshs.png)\nEntonces, le pregunto al asistente si se han capturado flujos, responde con esto\n! [] (/wp-content/uploads/2024/07/events.png)\nPodemos ver que los flujos fueron capturados y también me dio más información sobre los eventos detectados y la ruta con los nombres de los dispositivos. El primer evento parece estar relacionado con nuestro problema. Hasta ahora, la información parece precisa, obtengamos más detalles.! [] (/wp-content/uploads/2024/07/asistente-2.png)\nCon esto, podemos ver que el cliente envió múltiples intentos de SSH, podemos profundizar en uno de los flujos. Veamos qué más da.\n! [] (/WP-Content/uploads/2024/07/detalls.png)\nFinalmente, el asistente proporciona información detallada sobre las características que se aplican cada uno de los lúpulos al tráfico. En el segundo salto en Munich DC, podemos ver que las características de salida\" muestran el SD-WAN ACL` y un ‘Drop Informe’. El asistente proporciona su propia conclusión y también sospecha que el enrutador de Munich está dejando caer el tráfico. Con un poco más de trabajo, el agente podría decir el nombre del ACL y el número de secuencia que está dejando caer el tráfico. ¡Hemos identificado con éxito la raíz del problema! 😀 🎉\nLecciones aprendidas -Cuando comencé, quería ser súper cauteloso con los créditos ($$), así que estaba usando GPT-3.5-Turbo-16k que es más barato pero también menos inteligente. En algún momento, enfrenté problemas con la LLM entrando en un bucle de problemas, decidí probar GPT-4O y sentí una diferencia en la forma en que el agente estaba razonando.\nInicialmente, estaba usando una temperatura LLM = 0, esto estaba bien, pero las respuestas carecían de variedad y detalles, necesitaba hacerlo más hablador. Ajustar la temperatura = 0.9 me dio un buen equilibrio entre la charla y la corrección (aunque a veces el agente todavía proporciona información que es cuestionable en función de las salidas) Los problemas de solución de problemas podrían ser difíciles a veces, principalmente confié en la impresión de salidas mientras se ejecutaban las funciones y las salidas del agente en el terminal. Me permite entender qué herramientas estaba usando el agente y el pedido. Además, pude ver lo que regresaban las herramientas. Aquí hay un ejemplo: ! [] (/wp-content/uploads/2024/07/terminal.png)\nEl texto en verde indica las herramientas al que está accediendo al agente. El texto amarillo es la información devuelta por una función. En este caso, podemos ver que el agente llamado \" get_entry_time_and_state \" Función para que pueda obtener información necesaria para llamar a la siguiente función \" get_flow_detail \"\nHay mejores herramientas disponibles para ayudar con la resolución de problemas como [Langsmith Tr] (https://python.langchain.com/v0.2/docs/how_to/debugging/) [acing] (https://python.langchain.com/v0.2/docs/how_to/debugging/), lo explicará el futuro.\nLa solicitud del sistema de mi agente tenía que ser refinado varias veces, a menudo descubrí que necesitaba proporcionar más detalles para manejar ciertas situaciones correctamente, especialmente cuando la salida de una función era necesaria para llamar a otra o para manejar situaciones inesperadas. Creo que todavía se puede mejorar, de hecho, quiero escribir un mensaje totalmente diferente para intentar que el agente ejecute todas las herramientas por sí misma y simplemente devuelva una conclusión después de analizar todas las salidas. Conclusión En general, fue un buen (y largo) ejercicio aprender y construir mi primer asistente. Me siento feliz con el resultado, ya que pude consultarme el objetivo. Al mismo tiempo, reconozco que hay muchas cosas que podrían mejorarse para hacer que los resultados sean más confiables y significativos. Además, hay mucha más información que NWPI puede mostrar, por lo que las herramientas definitivamente se pueden extender.\nComo siguiente paso, planeo aprender Langchain correctamente y comprender cómo puedo implementar múltiples agentes para mejorar la funcionalidad y la confiabilidad de mi asistente.\n¡Espero que esta publicación te ayude de la misma manera que la presentación de Cisco Live me ayudó!\n",
  "wordCount" : "2061",
  "inLanguage": "es",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/edificio-my-primero-sd-wan-ai-asistant-with-langchain%20/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "NetWithAlex",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/assets/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/es/" accesskey="h" title="NetWithAlex (Alt + H)">NetWithAlex</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://localhost:1313/" title="English"
                            aria-label="English">En</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/es/" title="Inicio">
                    <span>Inicio</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/archives/" title="Archivo">
                    <span>Archivo</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/category/" title="Categorías">
                    <span>Categorías</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/about/" title="Sobre mí">
                    <span>Sobre mí</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/search/" title="🔍">
                    <span>🔍</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/es/">Inicio</a>&nbsp;»&nbsp;<a href="http://localhost:1313/es/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">10 min&nbsp;|&nbsp;Traducciones:
<ul class="i18n_list">
    <li>
        <a href="http://localhost:1313/building-my-first-sd-wan-ai-assistant-with-langchain/">En</a>
    </li>
</ul>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Tabla de Contenidos</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introducci%c3%b3n" aria-label="Introducción">Introducción</a></li>
                <li>
                    <a href="#sobre-la-configuraci%c3%b3n" aria-label="sobre la configuración">sobre la configuración</a></li>
                <li>
                    <a href="#mi-objetivo" aria-label="mi objetivo">mi objetivo</a></li>
                <li>
                    <a href="#planificaci%c3%b3n-y-construcci%c3%b3n" aria-label="Planificación y construcción">Planificación y construcción</a><ul>
                        
                <li>
                    <a href="#desaf%c3%ado-1" aria-label="desafío 1">desafío 1</a></li>
                <li>
                    <a href="#desaf%c3%ado-2" aria-label="desafío 2">desafío 2</a><ul>
                        
                <li>
                    <a href="#encuentra-la-api-para-iniciar-el-rastro" aria-label="Encuentra la API para iniciar el rastro">Encuentra la API para iniciar el rastro</a></li>
                <li>
                    <a href="#encuentra-la-api-para-confirmar-que-la-traza-se-est%c3%a1-ejecutando" aria-label="Encuentra la API para confirmar que la traza se está ejecutando">Encuentra la API para confirmar que la traza se está ejecutando</a></li>
                <li>
                    <a href="#encuentra-la-api-para-darme-detalles-de-los-flujos" aria-label="Encuentra la API para darme detalles de los flujos">Encuentra la API para darme detalles de los flujos</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#demostraci%c3%b3n" aria-label="demostración">demostración</a></li>
                <li>
                    <a href="#lecciones-aprendidas" aria-label="Lecciones aprendidas">Lecciones aprendidas</a></li>
                <li>
                    <a href="#conclusi%c3%b3n" aria-label="Conclusión">Conclusión</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="introducción">Introducción<a hidden class="anchor" aria-hidden="true" href="#introducción">#</a></h2>
<p>Ha pasado un tiempo desde que quería subirme al tren LLM y aprender a usar uno de los marcos populares. Hace unos meses, vi una gran presentación [de Cisco Live] (<a href="https://www.ciscolive.com/on-demand/on-demand-library.html?search=Jesus&amp;search=jesus#/session/1707505627331001pilj">https://www.ciscolive.com/on-demand/on-demand-library.html?search=Jesus&search=jesus#/session/1707505627331001pilj</a>) por mi buen amigo, y me dio la determinación que finalmente me necesitaba para que finalmente dijera el tema.</p>
<p>Desde entonces, he estado investigando y pensando en un buen caso de uso para que pueda poner como objetivo de mi proceso de aprendizaje. Después de considerar diferentes opciones, decidí construir un asistente de IA SD-WAN que podría ayudarme a solucionar problemas de un problema SD-WAN. Aprovechando las herramientas disponibles, decidí que mi asistente sería un experto en la funcionalidad de [/Netwide-Wide-Wide-Path-Insights-An-Introduction/) [Work Buid Rath Insights] (/Network-Wide-Path-Insights-An-Introduction/).</p>
<p>En esta publicación, quiero compartir un poco de mi experiencia para construirlo y, por supuesto, mostrar algunos de los resultados. Para una mejor comprensión, sugiero tener el [G] (<a href="https://github.com/aruiz-p/sdwan-assistant">https://github.com/aruiz-p/sdwan-assistant</a>) [repositorio de iThub] (<a href="https://github.com/aruiz-p/sdwan-assistant">https://github.com/aruiz-p/sdwan-assistant</a>) se abrió a medida que avanza por la publicación.</p>
<h2 id="sobre-la-configuración">sobre la configuración<a hidden class="anchor" aria-hidden="true" href="#sobre-la-configuración">#</a></h2>
<p>Mi laboratorio SD-WAN está ejecutando 20.12.3 en el administrador y los bordes WAN están utilizando 17.9.4a. Tengo una topología muy simple que se parece a esto:</p>
<p>! [] (/wp-content/uploads/2024/07/topology-2.png)</p>
<p>El lenguaje de programación utilizado es Python y el marco que elegí interactuar con la LLM es Langchain. Utilicé Operai Model GPT-4O y un BOX BOT para la interacción. El repositorio se puede encontrar [aquí] (<a href="https://github.com/aruiz-p/sdwan-assistant%29">https://github.com/aruiz-p/sdwan-assistant)</a>.</p>
<h2 id="mi-objetivo">mi objetivo<a hidden class="anchor" aria-hidden="true" href="#mi-objetivo">#</a></h2>
<p>En aras del contexto, la resolución de problemas dentro de una tela SD-WAN no es fácil porque el tráfico está encriptado, las políticas dictan cómo fluirá el tráfico, podría haber múltiples rutas a un destino, los próximos lúpulos se pueden cambiar con políticas, hay múltiples lúpulos involucrados y más. Descubrir toda esta información lleva mucho tiempo y no es un proceso sencillo.</p>
<p>[NWPI] (/Trace de insights-An-Introduction/) de NWPI] es una herramienta que mejora enormemente el proceso de solución de problemas, ya que dará información y visibilidad de lúpulo por hop. Se puede iniciar fácilmente desde la interfaz de usuario del gerente, detectará flujos basados ​​en filtros especificados y puede navegar para obtener toda la visibilidad que necesita. Es una herramienta muy compleja y completa. Como describí antes, quería usar este proyecto como un patio de recreo para aprender y, dado que no tenía experiencia previa con LLMS o Langchain, establecí un objetivo simple:</p>
<p>_ ** Construye un asistente que pueda iniciar una traza NWPI y darme detalles de los flujos. ** _</p>
<h2 id="planificación-y-construcción">Planificación y construcción<a hidden class="anchor" aria-hidden="true" href="#planificación-y-construcción">#</a></h2>
<p>Ok, tenía mi objetivo, pero ¿cómo comenzar?</p>
<p>Tomé un enfoque práctico que significaba que no aprendí a Langchain desde cero y en su lugar tomé el [repositorio de la sesión en vivo de Cisco] (<a href="https://github.com/jillesca/cleurdevnet-3707">https://github.com/jillesca/cleurdevnet-3707</a>) como base y construida sobre eso. Las razones para elegir este repositorio fueron simples:</p>
<ol>
<li>Se explicó en las sesiones, así que tuve una idea general de las tecnologías y su propósito.</li>
<li>Pensé que sería fácil ajustar a mi caso de uso (por ejemplo, también uso webex, interactuaré con dispositivos de red, vi cómo las herramientas podrían reemplazarse con la mía)</li>
</ol>
<p>Tuve que limpiar un poco antes de comenzar, esto me requirió que entendiera lo que era esencial para albergar el LLM e interactuar con él. Afortunadamente, el repositorio tenía una estructura organizada que facilitaba la comprensión.</p>
<p>De la sesión, aprendí sobre [Langchain Tools] (<a href="https://python.langchain.com/v0.1/docs/modules/tools/%29">https://python.langchain.com/v0.1/docs/modules/tools/)</a>, así que sabía que podría crear funciones que mi agente podría usar para realizar diferentes acciones. En este caso, las acciones serían algo así como comenzar esos rastros y obtener información de ellos</p>
<h3 id="desafío-1">desafío 1<a hidden class="anchor" aria-hidden="true" href="#desafío-1">#</a></h3>
<p>Necesitaba familiarizarme con la API de NWPI, en este punto sabía que había visto en algún lugar de la documentación de la API de que algunas operaciones estaban disponibles, pero nunca me había tomado el tiempo para analizarlas. Para mi sorpresa, las acciones específicas de comenzar un rastro y obtener detalles no se incluyeron &hellip; había información sobre cómo comenzar una &ldquo;tarea&rdquo; también conocida como &ldquo;tarea automática&rdquo;, que no es lo mismo que el &ldquo;rastro&rdquo; que tenía en mente. En este punto, necesitaba decidir si iría por la forma &ldquo;oficial&rdquo; y tal vez más fácil o explorar una alternativa para lograr exactamente lo que quería.Sabiendo que casi todo está impulsado por API, utilicé la pestaña Inspeccionar de mi navegador y comencé a explorar las API activadas cuando comencé un rastro a través de la interfaz de usuario. Después de un primer pase rápido, determiné que era factible y comencé a recopilar la información que necesitaba.</p>
<h3 id="desafío-2">desafío 2<a hidden class="anchor" aria-hidden="true" href="#desafío-2">#</a></h3>
<p>Ya sabía que tendría que hacer un análisis para hacer realidad mi idea, pero subestimé cuánto necesitaría hacer. De hecho, la dificultad de esta tarea me mantuvo alejado del proyecto durante algún tiempo, ya que se volvió cada vez más compleja.</p>
<p>En mi mente solo había 3 tareas &ldquo;simples&rdquo;:</p>
<ol>
<li>Encuentra la API para iniciar el rastro</li>
<li>Encuentre la API para confirmar que la traza se está ejecutando</li>
<li>Encuentra la API para darme detalles de los flujos</li>
</ol>
<h4 id="encuentra-la-api-para-iniciar-el-rastro">Encuentra la API para iniciar el rastro<a hidden class="anchor" aria-hidden="true" href="#encuentra-la-api-para-iniciar-el-rastro">#</a></h4>
<p>Comenzar un rastro desde la interfaz de usuario es muy simple, solo necesita una ID de sitio y una ID de VPN. Sin embargo, existen verificaciones subyacentes que damos por sentado.</p>
<ol>
<li>La identificación del sitio realmente es necesaria para identificar los dispositivos para iniciar el rastro.</li>
<li>Hay un montón de opciones (información de QoS, visibilidad de arte, visibilidad de la aplicación, DIA, etc.) que dependen de la versión.</li>
<li>La VPN debe existir.</li>
</ol>
<p>Para hacer esto, creé la función <code>get_device_details_from_site</code> para poder encontrar información relacionada de los dispositivos para iniciar el rastreo. Necesitaba:</p>
<ul>
<li>versiones</li>
<li>Números de serie</li>
<li>nombres</li>
<li>Estado de accesibilidad.</li>
</ul>
<p>Luego, creé la función <code>start_trace</code> que recibiría la información obtenida previamente y otros filtros. Mantuve los filtros lo más simples posible, dejando solo una opción para especificar una subred de origen y destino. Hay muchas opciones de rastreo para las que no hice ningún tipo de verificación de versión antes de ejecutarla, solo lo hice para las ideas de QoS que requiere la versión 17.9 o posterior. Esta función devuelve alguna información necesaria más adelante para verificar el estado.</p>
<h4 id="encuentra-la-api-para-confirmar-que-la-traza-se-está-ejecutando">Encuentra la API para confirmar que la traza se está ejecutando<a hidden class="anchor" aria-hidden="true" href="#encuentra-la-api-para-confirmar-que-la-traza-se-está-ejecutando">#</a></h4>
<p>Esta fue probablemente la tarea más fácil. Creé la función <code>verify_trace_state</code> y con la ayuda del LLM se puede ejecutar unos segundos después de comenzar el rastro. Devuelve el estado, que también es necesario para obtener información más adelante.</p>
<h4 id="encuentra-la-api-para-darme-detalles-de-los-flujos">Encuentra la API para darme detalles de los flujos<a hidden class="anchor" aria-hidden="true" href="#encuentra-la-api-para-darme-detalles-de-los-flujos">#</a></h4>
<p>Esta fue la tarea más compleja y lenta. En mi mente, verificar el resultado de un rastro es muy simple, sin embargo, cuando recibimos la información en trozos, a través de diferentes llamadas comienza a ser complicada.</p>
<p>Traté de replicar el proceso que paso en la interfaz de usuario:</p>
<ol>
<li>Vea las ideas de la traza y verifique los flujos que fueron capturados (si los hubo)</li>
<li>Para la lista de flujos, busque el que tuviera el botón de &ldquo;lectura&rdquo; en rojo (problema detectado) y haga clic para obtener más detalles.</li>
<li>Expanda la vista de flujo para obtener acceso a las funcionalidades avanzadas para que pueda determinar las características que el paquete está pasando en cada uno de los lúpulos.</li>
</ol>
<p>Para capturar los flujos para la traza, creé la función <code>get_flow_summary</code>. Esta función devolverá la lista de flujos capturados, verá detalles como SRC/DST, aplicación y protocolo. Esto es útil para identificar el ID de flujo que le interesa obtener más detalles.</p>
<p>Creé la función <code>Trace_readout</code> para obtener un resumen de los eventos que la traza capturó junto con la ruta afectada. Por ejemplo, podría ver que un flujo SSH no funciona entre el dispositivo X y el dispositivo Y.</p>
<p>Ok, una vez que haya identificado el flujo y los eventos que le interesan, puede obtener información detallada del flujo con la función <code>get_flow_detail</code>. Esto le dará información de salto de lúpulo como:</p>
<ul>
<li>Brincar</li>
<li>Evento</li>
<li>colores locales/remotos</li>
<li>Interfaces de entrada/salida</li>
<li>Características de entrada/salida aplicadas a los paquetes</li>
<li>Decisión de retención de características</li>
</ul>
<p>Con esta información es posible ver todo tipo de cosas, como ACL, tipo de políticas aplicadas, por qué se enruta un paquete a través de un color específico, cae, confirma que su política funciona como se esperaba, etc.</p>
<p>Ok, creo que eso es todo!</p>
<h2 id="demostración">demostración<a hidden class="anchor" aria-hidden="true" href="#demostración">#</a></h2>
<p>Comencé creando un ACL para bloquear la comunicación y la apliqué en el lado de DC.</p>
<p><code> </code> ``
Munich_DC100-1 - Configuración de ACL</p>
<p>sdwan
interfaz gigabitethernet2
Access-List ACL_DROP_172_16_10_0 OUT</p>
<p>política
Access-List ACL_DROP_172_16_10_0
secuencia 1
fósforo
Fuente-IP 172.16.10.0/24
Destino-IP 172.16.100.0/24
!
caída de acción
conte dropcounter
!
!
Aceptación de acción predeterminada
!</p>
<p><code> </code> ``</p>
<p>¿Mi asistente detectará esto? 🤔</p>
<p>A continuación, comienzo la aplicación y solicito que el LLM inicie un rastro. Puedo confirmar en la interfaz de usuario que se crea.</p>
<p>! [] (/WP-Content/uploads/2024/07/starttrace.png)! [] (/wp-content/uploads/2024/07/ui-trace.png)</p>
<p>Empiezo un par de conexiones SSH de Branch a DC</p>
<p>! [] (/wp-content/uploads/2024/07/sshs.png)</p>
<p>Entonces, le pregunto al asistente si se han capturado flujos, responde con esto</p>
<p>! [] (/wp-content/uploads/2024/07/events.png)</p>
<p>Podemos ver que los flujos fueron capturados y también me dio más información sobre los eventos detectados y la ruta con los nombres de los dispositivos. El primer evento parece estar relacionado con nuestro problema. Hasta ahora, la información parece precisa, obtengamos más detalles.! [] (/wp-content/uploads/2024/07/asistente-2.png)</p>
<p>Con esto, podemos ver que el cliente envió múltiples intentos de SSH, podemos profundizar en uno de los flujos. Veamos qué más da.</p>
<p>! [] (/WP-Content/uploads/2024/07/detalls.png)</p>
<p>Finalmente, el asistente proporciona información detallada sobre las características que se aplican cada uno de los lúpulos al tráfico. En el segundo salto en Munich DC, podemos ver que las <code>características de salida&quot; muestran el </code>SD-WAN ACL` y un &lsquo;Drop Informe&rsquo;. El asistente proporciona su propia conclusión y también sospecha que el enrutador de Munich está dejando caer el tráfico. Con un poco más de trabajo, el agente podría decir el nombre del ACL y el número de secuencia que está dejando caer el tráfico. ¡Hemos identificado con éxito la raíz del problema! 😀 🎉</p>
<h2 id="lecciones-aprendidas">Lecciones aprendidas<a hidden class="anchor" aria-hidden="true" href="#lecciones-aprendidas">#</a></h2>
<p>-Cuando comencé, quería ser súper cauteloso con los créditos ($$), así que estaba usando GPT-3.5-Turbo-16k que es más barato pero también menos inteligente. En algún momento, enfrenté problemas con la LLM entrando en un bucle de problemas, decidí probar GPT-4O y sentí una diferencia en la forma en que el agente estaba razonando.</p>
<ul>
<li>Inicialmente, estaba usando una temperatura LLM = 0, esto estaba bien, pero las respuestas carecían de variedad y detalles, necesitaba hacerlo más hablador. Ajustar la temperatura = 0.9 me dio un buen equilibrio entre la charla y la corrección (aunque a veces el agente todavía proporciona información que es <em>cuestionable</em> en función de las salidas)</li>
<li>Los problemas de solución de problemas podrían ser difíciles a veces, principalmente confié en la impresión de salidas mientras se ejecutaban las funciones y las salidas del agente en el terminal. Me permite entender qué herramientas estaba usando el agente y el pedido. Además, pude ver lo que regresaban las herramientas. Aquí hay un ejemplo:</li>
</ul>
<p>! [] (/wp-content/uploads/2024/07/terminal.png)</p>
<p>El texto en verde indica las herramientas al que está accediendo al agente. El texto amarillo es la información devuelta por una función. En este caso, podemos ver que el agente llamado <code>&quot; get_entry_time_and_state &quot;</code> Función para que pueda obtener información necesaria para llamar a la siguiente función <code>&quot; get_flow_detail &quot;</code></p>
<p>Hay mejores herramientas disponibles para ayudar con la resolución de problemas como [Langsmith Tr] (<a href="https://python.langchain.com/v0.2/docs/how_to/debugging/">https://python.langchain.com/v0.2/docs/how_to/debugging/</a>) [acing] (<a href="https://python.langchain.com/v0.2/docs/how_to/debugging/%29">https://python.langchain.com/v0.2/docs/how_to/debugging/)</a>, lo explicará el futuro.</p>
<ul>
<li>La solicitud del sistema de mi agente tenía que ser refinado varias veces, a menudo descubrí que necesitaba proporcionar más detalles para manejar ciertas situaciones correctamente, especialmente cuando la salida de una función era necesaria para llamar a otra o para manejar situaciones inesperadas. Creo que todavía se puede mejorar, de hecho, quiero escribir un mensaje totalmente diferente para intentar que el agente ejecute todas las herramientas por sí misma y simplemente devuelva una conclusión después de analizar todas las salidas.</li>
</ul>
<h2 id="conclusión">Conclusión<a hidden class="anchor" aria-hidden="true" href="#conclusión">#</a></h2>
<p>En general, fue un buen (y largo) ejercicio aprender y construir mi primer asistente. Me siento feliz con el resultado, ya que pude consultarme el objetivo. Al mismo tiempo, reconozco que hay muchas cosas que podrían mejorarse para hacer que los resultados sean más confiables y significativos. Además, hay mucha más información que NWPI puede mostrar, por lo que las herramientas definitivamente se pueden extender.</p>
<p>Como siguiente paso, planeo aprender Langchain correctamente y comprender cómo puedo implementar múltiples agentes para mejorar la funcionalidad y la confiabilidad de mi asistente.</p>
<p>¡Espero que esta publicación te ayude de la misma manera que la presentación de Cisco Live me ayudó!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/es/">NetWithAlex</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copiar';

        function copyingDone() {
            copybutton.innerHTML = '¡copiado!';
            setTimeout(() => {
                copybutton.innerHTML = 'copiar';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
