<!DOCTYPE html>
<html lang="es" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Creando mi primer asistente de AI SD-WAN con Langchain | NetWithAlex</title>
<meta name="keywords" content="">
<meta name="description" content="Descubre cómo los LLMs se pueden integrar con Cisco SD-WAN para hacer troubleshooting de manera sencilla y sin estrés">
<meta name="author" content="Alex">
<link rel="canonical" href="http://localhost:1313/creando-mi-primer-asistente-ai-con-langchain/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/assets/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/building-my-first-sd-wan-ai-assistant-with-langchain/">
<link rel="alternate" hreflang="es" href="http://localhost:1313/creando-mi-primer-asistente-ai-con-langchain/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://localhost:1313/creando-mi-primer-asistente-ai-con-langchain/">
  <meta property="og:site_name" content="NetWithAlex">
  <meta property="og:title" content="Creando mi primer asistente de AI SD-WAN con Langchain">
  <meta property="og:description" content="Descubre cómo los LLMs se pueden integrar con Cisco SD-WAN para hacer troubleshooting de manera sencilla y sin estrés">
  <meta property="og:locale" content="es">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-10T18:51:08+00:00">
    <meta property="article:modified_time" content="2024-07-10T18:51:08+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Creando mi primer asistente de AI SD-WAN con Langchain">
<meta name="twitter:description" content="Descubre cómo los LLMs se pueden integrar con Cisco SD-WAN para hacer troubleshooting de manera sencilla y sin estrés">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/es/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Creando mi primer asistente de AI SD-WAN con Langchain",
      "item": "http://localhost:1313/creando-mi-primer-asistente-ai-con-langchain/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Creando mi primer asistente de AI SD-WAN con Langchain",
  "name": "Creando mi primer asistente de AI SD-WAN con Langchain",
  "description": "Descubre cómo los LLMs se pueden integrar con Cisco SD-WAN para hacer troubleshooting de manera sencilla y sin estrés",
  "keywords": [
    
  ],
  "articleBody": "Introducción Hace tiempo que quería subirme al tren de los LLM y aprender a usar uno de los frameworks más populares. Hace unos meses, vi una excelente presentación en Cisco Live de mi buen amigo Jesús, y eso me dio la determinación que necesitaba para finalmente profundizar en el tema.\nDesde entonces, he estado investigando y pensando en un buen caso de uso que pudiera servir como objetivo para mi proceso de aprendizaje. Después de considerar diferentes opciones, decidí construir un asistente de IA para SD-WAN que pudiera ayudarme a solucionar problemas relacionados con esta tecnología. Aprovechando las herramientas disponibles, decidí que mi asistente sería un experto en la funcionalidad de Network Wide Rath Insights.\nEn esta publicación, quiero compartir un poco de mi experiencia para construirlo y, por supuesto, mostrar algunos de los resultados. Para entenderlo mejor, sugiero tener el repositorio de Github abierto y consultarlo a medida que avanzas por la publicación.\nSobre la configuración Mi laboratorio SD-WAN está corriendo la versión 20.12.3 y WAN edges están utilizando 17.9.4a. Tengo una topología muy simple:\nEl lenguaje de programación utilizado es Python y el framework que elegí para interactuar con el LLM es Langchain. Utilicé OpenAI Model GPT-4o y un bot de webex para la interacción. El repositorio se puede encontrar aquí.\nMi objetivo Para dar contexto, la solución de problemas dentro de una infraestructura SD-WAN no es sencilla debido a que el tráfico está cifrado, las políticas dictan cómo fluirá el tráfico, pueden existir múltiples caminos hacia un destino, los siguientes saltos pueden cambiar según las políticas, hay múltiples saltos involucrados, entre otros factores. Determinar toda esta información lleva tiempo y no es un proceso directo.\nNWPI Trace es una herramienta que mejora significativamente el proceso de troubleshooting, ya que proporciona información y visibilidad salto a salto. Se puede iniciar fácilmente desde la interfaz del Manager, detecta flujos según filtros especificados y permite explorar la red para obtener toda la visibilidad necesaria. Es una herramienta muy completa y avanzada.\nComo mencioné antes, quería utilizar este proyecto como un campo de prueba para aprender, y dado que no tenía experiencia previa con LLMs o LangChain, establecí un objetivo sencillo:\nConstruir un asistente que pueda iniciar una traza NWPI y darme detalles de los flujos\nPlanificación y construcción Ok, tengo mi objetivo, pero ¿cómo comienzo?\nTomé un enfoque práctico que significaba que no aprendí Langchain desde cero y en su lugar tomé el repositorio de la sesión de Cisco Live como base y construí sobre eso. Las razones para elegir este repositorio fueron simples:\nSe explicó en las sesiones, así que tuve una idea general de las tecnologías y su propósito. Pensé que sería fácil ajustar a mi caso de uso (por ejemplo, también uso webex, interactuaré con dispositivos de red, vi cómo las herramientas podrían reemplazarse con la mías) Tuve que limpiar un poco antes de comenzar, esto me requirió que entendiera lo que era esencial para hostear el LLM e interactuar con él. Afortunadamente, el repositorio tiene una estructura organizada que facilita la comprensión.\nDe la sesión, aprendí sobre [Langchain Tools] (https://python.langchain.com/v0.1/docs/modules/tools/), así que sabía que podría crear funciones que mi agente podría usar para realizar diferentes acciones. En este caso, las acciones serían algo así como comenzar trazas y leer la información obtenida.\nDesafío 1 Necesitaba familiarizarme con la APIs de NWPI. En este punto, sabía que en algún lugar de la documentación de la API había visto que algunas operaciones estaban disponibles, pero nunca me había tomado el tiempo de analizarlas en detalle. Para mi sorpresa, las acciones específicas de iniciar un trace y obtener sus detalles no estaban incluidas… En su lugar, encontré información sobre cómo iniciar una “tarea” o “Auto-on Task”, que no es lo mismo que el “Trace” que tenía en mente.\nEn este punto, tenía que decidir si seguir el camino “oficial” (quizás más fácil) o explorar una alternativa para lograr exactamente lo que quería.\nSabiendo que casi todo en SD-WAN es impulsado por APIs, usé la pestaña de inspección de mi navegador y comencé a explorar las APIs que se activaban cuando iniciaba un trace desde la UI. Después de una primera revisión rápida, determiné que era factible y comencé a recopilar la información que necesitaba.\nDesafío 2 Ya sabía que tendría que hacer algo de análisis para convertir mi idea en realidad, pero subestimé cuánto tendría que hacer. De hecho, la dificultad de esta tarea me alejó del proyecto por un tiempo, ya que se volvió cada vez más compleja.\nEn mi mente solo había 3 tareas “simples”:\nEncontrar la API para iniciar el trace Encontrar la API para confirmar que el trace está en ejecución Encontrar la API que me dé detalles de los flujos API para iniciar la traza Iniciar la traza desde la interfaz de usuario es muy sencillo, solo necesitas un Site ID y un VPN ID. Sin embargo, hay verificaciones subyacentes que damos por sentadas.\nEl Site ID realmente es necesario para identificar los dispositivos en los que iniciar la traza Hay una serie de opciones (informes de QoS, visibilidad ART, visibilidad de aplicaciones, DIA, etc.) que dependen de la versión La VPN debe existir Para realizar esto, creé la función get_device_details_from_site para poder encontrar la información relacionada con los dispositivos en los que iniciar el trace. Necesitaba:\nversiones números de serie nombres estado de conectividad Luego, creé la función start_trace que recibiría la información obtenida previamente y otros filtros. Mantuve los filtros lo más simples posible, dejando solo la opción de especificar una subred de origen y destino. Hay muchas opciones para la traza para las cuales no realicé ninguna verificación de versión antes de ejecutarla, solo lo hice para los informes de QoS, que requieren la versión 17.9 o posterior. Esta función devuelve información necesaria más adelante para verificar el estado.\nAPI para confirmar que la traza se está ejecutando Esta fue probablemente la tarea más fácil. Creé la función verify_trace_state y con la ayuda del LLM se puede ejecutar unos segundos después de comenzar la traza. Devuelve el estado, que también es necesario para obtener información más adelante.\nAPI para darme detalles de los flujos Esta fue la tarea más compleja y tardada. En mi mente, verificar el resultado de una traza es muy simple, sin embargo, cuando recibimos la información en pedazos, a través de diferentes llamadas comienza a ser complicado.\nIntenté replicar el proceso que sigo en la interfaz de usuario:\nVer las estadísticas del trace y comprobar los flujos que fueron capturados (si es que hay alguno). Para la lista de flujos, buscar el que tiene el botón “readout” en rojo (problema detectado) y hacer clic para obtener más detalles. Expandir la vista del flujo para acceder a las funcionalidades avanzadas y así determinar las características por las que el paquete pasa en cada uno de los saltos. Para obtener los flujos capturados en el trace, creé la función get_flow_summary. Esta función devolverá la lista de los flujos capturados. Verás detalles como origen/destino, aplicación y protocolo. Esto es útil para identificar el flujo cuyo id te interesa para obtener más detalles.\nCreé la función trace_readout para obtener un resumen de los eventos que el trace capturó junto con el camino afectado. Por ejemplo, podrías ver que un flujo SSH no está funcionando entre el Dispositivo X y el Dispositivo Y.\nUna vez que hayas identificado el flujo y los eventos que te interesan, puedes obtener información detallada del flujo con la función get_flow_detai. Esto te proporcionará información como:\nHops Eventos Colores locales/remotos Interfaces de entrada/salida Funcionalidades de entrada/salida aplicadas a los paquetes Funcionalidad que determina decisión de ruteo Con esta información es posible ver todo tipo de cosas, como ACLs, tipo de políticas aplicadas, por qué un paquete fue enviado a través de un color específico, caídas, confirmar que tu política está funcionando como se espera, etc.\nOk, creo que eso es todo\nDemo Comencé creando un ACL para bloquear la comunicación y la apliqué en el lado de DC.\nMunich_DC100-1 - ACL configuration sdwan interface GigabitEthernet2 access-list ACL_Drop_172_16_10_0 out policy access-list ACL_Drop_172_16_10_0 sequence 1 match source-ip 172.16.10.0/24 destination-ip 172.16.100.0/24 ! action drop count dropCounter ! ! default-action accept ! ¿Mi asistente detectará esto? 🤔\nA continuación, comienzo la aplicación y solicito que el LLM inicie una traza. Puedo confirmar en la UI que se crea.\nLanzo un par de conexiones SSH de Branch a DC\nDespués, le pregunto al asistente si se han capturado flujos, responde con esto\nPodemos ver que los flujos fueron capturados y también me dio más información sobre los eventos detectados y el camino que tomaron los paquetes incluyendo los nombres de los dispositivos. El primer evento parece estar relacionado con nuestro problema. Hasta ahora, la información parece precisa, voy a pedir más detalles.\nCon esto, podemos ver que el cliente envió múltiples intentos de SSH, podemos profundizar en uno de los flujos. Veamos qué más da.\nFinalmente, el asistente proporciona información detallada sobre las funcionalidades que se aplican a cada uno de los flujos. En el segundo salto, en Munich DC, podemos ver que las funcionalidades de salida muestran el SD-WAN ACL y un ‘Drop Report’. El asistente proporciona su propia conclusión y también sospecha que el router de Munich está tirando el tráfico.\nCon un poco más de trabajo, el agente podría decir el nombre del ACL y el número de secuencia responsable de tirar el tráfico. ¡Hemos identificado con éxito la raíz del problema! 😀 🎉\nLecciones aprendidas Cuando comencé, quería ser súper cauteloso con los créditos ($$), así que estaba usando GPT-3.5-Turbo-16k que es más barato pero también menos inteligente. En algún momento, enfrenté problemas con el LLM entrando en un loop, decidí probar GPT-4O y sentí una diferencia en la forma en que el agente estaba razonando. Inicialmente, estaba usando una temperatura LLM = 0, esto estaba bien, pero las respuestas carecían de variedad y detalles, necesitaba hacerlo más hablador. Ajustar la temperatura = 0.9 me dio un buen equilibrio entre la charla y la corrección (aunque a veces el agente todavía proporciona información que es cuestionable en función de las salidas) Hacer troubleshooting puede ser difícil a veces, principalmente me basé en imprimir los resultados de las funciones mientras estas se ejecutaban y el agente imprimía en la terminal. Esto me permitió entender qué herramientas estaba utilizando el agente y el orden en que las utilizaba. Además, pude ver qué estaban devolviendo esas herramientas. Aquí tienes un ejemplo: El texto en verde indica las herramientas a las que está accediendo al agente. El texto amarillo es la información devuelta por una función. En este caso, podemos ver que el agente llamó la función \"get_entry_time_and_state\" para que obtener información necesaria para llamar a la siguiente función \"get_flow_detail\"\nHay mejores herramientas disponibles para ayudar con la resolución de problemas como LangSmith Tracing, lo voy a explorar en el futuro.\nEl prompts de mi agente tuvo que ser refinado varias veces, a menudo me di cuenta de que necesitaba proporcionar más detalles para manejar ciertas situaciones correctamente, especialmente cuando la salida de una función era necesaria para llamar a otra o para manejar situaciones inesperadas. Creo que aún puede mejorarse, de hecho, quiero escribir un prompt completamente diferente para intentar hacer que el agente ejecute todas las herramientas por sí mismo y solo devuelva una conclusión después de analizar todas las salidas. Conclusión En general, fue un buen y largo ejercicio de aprendizaje esto de construir mi primer asistente. Me siento contento con el resultado, ya que logré alcanzar mi objetivo. Al mismo tiempo, reconozco que hay muchas cosas que se pueden mejorar para hacer que los resultados sean más confiables y significativos. Además, hay mucha más información que NWPI puede mostrar, por lo que las herramientas definitivamente se pueden ampliar.\nComo siguiente paso, planeo aprender LangChain adecuadamente y entender cómo puedo implementar múltiples agentes para mejorar la funcionalidad y confiabilidad de mi asistente.\n¡Espero que este post te ayude de la misma manera que la presentación de Cisco Live me ayudó a mí!\n",
  "wordCount" : "2003",
  "inLanguage": "es",
  "datePublished": "2024-07-10T18:51:08Z",
  "dateModified": "2024-07-10T18:51:08Z",
  "author":{
    "@type": "Person",
    "name": "Alex"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/creando-mi-primer-asistente-ai-con-langchain/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "NetWithAlex",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/assets/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/es/" accesskey="h" title="NetWithAlex (Alt + H)">NetWithAlex</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://localhost:1313/" title="English"
                            aria-label="English">En</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/es/" title="Inicio">
                    <span>Inicio</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/archives/" title="Archivo">
                    <span>Archivo</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/category/" title="Categorías">
                    <span>Categorías</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/sobre-mi/" title="Sobre mí">
                    <span>Sobre mí</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/es/search/" title="🔍">
                    <span>🔍</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/es/">Inicio</a>&nbsp;»&nbsp;<a href="http://localhost:1313/es/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Creando mi primer asistente de AI SD-WAN con Langchain
    </h1>
    <div class="post-meta"><span title='2024-07-10 18:51:08 +0000 +0000'>julio 10, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Alex&nbsp;|&nbsp;Traducciones:
<ul class="i18n_list">
    <li>
        <a href="http://localhost:1313/building-my-first-sd-wan-ai-assistant-with-langchain/">En</a>
    </li>
</ul>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Tabla de Contenidos</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introducci%c3%b3n" aria-label="Introducción">Introducción</a></li>
                <li>
                    <a href="#sobre-la-configuraci%c3%b3n" aria-label="Sobre la configuración">Sobre la configuración</a></li>
                <li>
                    <a href="#mi-objetivo" aria-label="Mi objetivo">Mi objetivo</a></li>
                <li>
                    <a href="#planificaci%c3%b3n-y-construcci%c3%b3n" aria-label="Planificación y construcción">Planificación y construcción</a><ul>
                        
                <li>
                    <a href="#desaf%c3%ado-1" aria-label="Desafío 1">Desafío 1</a></li>
                <li>
                    <a href="#desaf%c3%ado-2" aria-label="Desafío 2">Desafío 2</a><ul>
                        
                <li>
                    <a href="#api-para-iniciar-la-traza" aria-label="API para iniciar la traza">API para iniciar la traza</a></li>
                <li>
                    <a href="#api-para-confirmar-que-la-traza-se-est%c3%a1-ejecutando" aria-label="API para confirmar que la traza se está ejecutando">API para confirmar que la traza se está ejecutando</a></li>
                <li>
                    <a href="#api-para-darme-detalles-de-los-flujos" aria-label="API para darme detalles de los flujos">API para darme detalles de los flujos</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#demo" aria-label="Demo">Demo</a></li>
                <li>
                    <a href="#lecciones-aprendidas" aria-label="Lecciones aprendidas">Lecciones aprendidas</a></li>
                <li>
                    <a href="#conclusi%c3%b3n" aria-label="Conclusión">Conclusión</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="introducción">Introducción<a hidden class="anchor" aria-hidden="true" href="#introducción">#</a></h2>
<p>Hace tiempo que quería subirme al tren de los LLM y aprender a usar uno de los frameworks más populares. Hace unos meses, vi una excelente <a href="https://www.ciscolive.com/on-demand/on-demand-library.html?search=Jesus&amp;search=jesus#/session/1707505627331001pilj">presentación en Cisco Live</a> de mi buen amigo Jesús, y eso me dio la determinación que necesitaba para finalmente profundizar en el tema.</p>
<p>Desde entonces, he estado investigando y pensando en un buen caso de uso que pudiera servir como objetivo para mi proceso de aprendizaje. Después de considerar diferentes opciones, decidí construir un asistente de IA para SD-WAN que pudiera ayudarme a solucionar problemas relacionados con esta tecnología. Aprovechando las herramientas disponibles, decidí que mi asistente sería un experto en la funcionalidad de  <a href="/Network-Wide-Path-Insights-An-Introduction/">Network Wide Rath Insights</a>.</p>
<p>En esta publicación, quiero compartir un poco de mi experiencia para construirlo y, por supuesto, mostrar algunos de los resultados. Para entenderlo mejor, sugiero tener el <a href="https://github.com/aruiz-p/sdwan-assistant">repositorio de Github</a> abierto y consultarlo a medida que avanzas por la publicación.</p>
<h2 id="sobre-la-configuración">Sobre la configuración<a hidden class="anchor" aria-hidden="true" href="#sobre-la-configuración">#</a></h2>
<p>Mi laboratorio SD-WAN está corriendo la versión 20.12.3 y WAN edges están utilizando 17.9.4a. Tengo una topología muy simple:</p>
<p><img loading="lazy" src="/wp-content/uploads/2024/07/topology-2.png"></p>
<p>El lenguaje de programación utilizado es Python y el framework que elegí para interactuar con el LLM es Langchain. Utilicé OpenAI Model GPT-4o y un bot de webex  para la interacción. El repositorio se puede encontrar <a href="https://github.com/aruiz-p/sdwan-assistant">aquí</a>.</p>
<h2 id="mi-objetivo">Mi objetivo<a hidden class="anchor" aria-hidden="true" href="#mi-objetivo">#</a></h2>
<p>Para dar contexto, la solución de problemas dentro de una infraestructura SD-WAN no es sencilla debido a que el tráfico está cifrado, las políticas dictan cómo fluirá el tráfico, pueden existir múltiples caminos hacia un destino, los siguientes saltos pueden cambiar según las políticas, hay múltiples saltos involucrados, entre otros factores. Determinar toda esta información lleva tiempo y no es un proceso directo.</p>
<p><a href="/network-wide-path-insights-an-introduction/">NWPI</a> Trace es una herramienta que mejora significativamente el proceso de troubleshooting, ya que proporciona información y visibilidad salto a salto. Se puede iniciar fácilmente desde la interfaz del Manager, detecta flujos según filtros especificados y permite explorar la red para obtener toda la visibilidad necesaria. Es una herramienta muy completa y avanzada.</p>
<p>Como mencioné antes, quería utilizar este proyecto como un campo de prueba para aprender, y dado que no tenía experiencia previa con LLMs o LangChain, establecí un objetivo sencillo:</p>
<blockquote>
<p><em><strong>Construir un asistente que pueda iniciar una traza NWPI y darme detalles de los flujos</strong></em></p>
</blockquote>
<h2 id="planificación-y-construcción">Planificación y construcción<a hidden class="anchor" aria-hidden="true" href="#planificación-y-construcción">#</a></h2>
<p>Ok, tengo mi objetivo, pero ¿cómo comienzo?</p>
<p>Tomé un enfoque práctico que significaba que no aprendí Langchain desde cero y en su lugar tomé el <a href="https://github.com/jillesca/cleurdevnet-3707">repositorio de la sesión de Cisco Live</a> como base y construí sobre eso. Las razones para elegir este repositorio fueron simples:</p>
<ol>
<li>Se explicó en las sesiones, así que tuve una idea general de las tecnologías y su propósito.</li>
<li>Pensé que sería fácil ajustar a mi caso de uso (por ejemplo, también uso webex, interactuaré con dispositivos de red, vi cómo las herramientas podrían reemplazarse con la mías)</li>
</ol>
<p>Tuve que limpiar un poco antes de comenzar, esto me requirió que entendiera lo que era esencial para <em>hostear</em> el LLM e interactuar con él. Afortunadamente, el repositorio tiene una estructura organizada que facilita la comprensión.</p>
<p>De la sesión, aprendí sobre [Langchain Tools] (<a href="https://python.langchain.com/v0.1/docs/modules/tools/%29">https://python.langchain.com/v0.1/docs/modules/tools/)</a>, así que sabía que podría crear funciones que mi agente podría usar para realizar diferentes acciones. En este caso, las acciones serían algo así como comenzar trazas y leer la información obtenida.</p>
<h3 id="desafío-1">Desafío 1<a hidden class="anchor" aria-hidden="true" href="#desafío-1">#</a></h3>
<p>Necesitaba familiarizarme con la APIs de NWPI. En este punto, sabía que en algún lugar de la documentación de la API había visto que algunas operaciones estaban disponibles, pero nunca me había tomado el tiempo de analizarlas en detalle. Para mi sorpresa, las acciones específicas de iniciar un trace y obtener sus detalles no estaban incluidas… En su lugar, encontré información sobre cómo iniciar una &ldquo;tarea&rdquo; o &ldquo;Auto-on Task&rdquo;, que no es lo mismo que el &ldquo;Trace&rdquo; que tenía en mente.</p>
<p>En este punto, tenía que decidir si seguir el camino &ldquo;oficial&rdquo; (quizás más fácil) o explorar una alternativa para lograr exactamente lo que quería.</p>
<p>Sabiendo que casi todo en SD-WAN es impulsado por APIs, usé la pestaña de inspección de mi navegador y comencé a explorar las APIs que se activaban cuando iniciaba un trace desde la UI. Después de una primera revisión rápida, determiné que era factible y comencé a recopilar la información que necesitaba.</p>
<h3 id="desafío-2">Desafío 2<a hidden class="anchor" aria-hidden="true" href="#desafío-2">#</a></h3>
<p>Ya sabía que tendría que hacer algo de análisis para convertir mi idea en realidad, pero subestimé cuánto tendría que hacer. De hecho, la dificultad de esta tarea me alejó del proyecto por un tiempo, ya que se volvió cada vez más compleja.</p>
<p>En mi mente solo había 3 tareas &ldquo;simples&rdquo;:</p>
<ol>
<li>Encontrar la API para iniciar el trace</li>
<li>Encontrar la API para confirmar que el trace está en ejecución</li>
<li>Encontrar la API que me dé detalles de los flujos</li>
</ol>
<h4 id="api-para-iniciar-la-traza">API para iniciar la traza<a hidden class="anchor" aria-hidden="true" href="#api-para-iniciar-la-traza">#</a></h4>
<p>Iniciar la traza desde la interfaz de usuario es muy sencillo, solo necesitas un Site ID y un VPN ID. Sin embargo, hay verificaciones subyacentes que damos por sentadas.</p>
<ul>
<li>El Site ID realmente es necesario para identificar los dispositivos en los que iniciar la traza</li>
<li>Hay una serie de opciones (informes de QoS, visibilidad ART, visibilidad de aplicaciones, DIA, etc.) que dependen de la versión</li>
<li>La VPN debe existir</li>
</ul>
<p>Para realizar esto, creé la función <code>get_device_details_from_site</code> para poder encontrar la información relacionada con los dispositivos en los que iniciar el trace. Necesitaba:</p>
<ul>
<li>versiones</li>
<li>números de serie</li>
<li>nombres</li>
<li>estado de conectividad</li>
</ul>
<p>Luego, creé la función <code>start_trace</code> que recibiría la información obtenida previamente y otros filtros. Mantuve los filtros lo más simples posible, dejando solo la opción de especificar una subred de origen y destino. Hay muchas opciones para la traza para las cuales no realicé ninguna verificación de versión antes de ejecutarla, solo lo hice para los informes de QoS, que requieren la versión 17.9 o posterior. Esta función devuelve información necesaria más adelante para verificar el estado.</p>
<h4 id="api-para-confirmar-que-la-traza-se-está-ejecutando">API para confirmar que la traza se está ejecutando<a hidden class="anchor" aria-hidden="true" href="#api-para-confirmar-que-la-traza-se-está-ejecutando">#</a></h4>
<p>Esta fue probablemente la tarea más fácil. Creé la función <code>verify_trace_state</code> y con la ayuda del LLM se puede ejecutar unos segundos después de comenzar la traza. Devuelve el estado, que también es necesario para obtener información más adelante.</p>
<h4 id="api-para-darme-detalles-de-los-flujos">API para darme detalles de los flujos<a hidden class="anchor" aria-hidden="true" href="#api-para-darme-detalles-de-los-flujos">#</a></h4>
<p>Esta fue la tarea más compleja y tardada. En mi mente, verificar el resultado de una traza es muy simple, sin embargo, cuando recibimos la información en pedazos, a través de diferentes llamadas comienza a ser complicado.</p>
<p>Intenté replicar el proceso que sigo en la interfaz de usuario:</p>
<ol>
<li>Ver las estadísticas del trace y comprobar los flujos que fueron capturados (si es que hay alguno).</li>
<li>Para la lista de flujos, buscar el que tiene el botón &ldquo;readout&rdquo; en rojo (problema detectado) y hacer clic para obtener más detalles.</li>
<li>Expandir la vista del flujo para acceder a las funcionalidades avanzadas y así determinar las características por las que el paquete pasa en cada uno de los saltos.</li>
</ol>
<p>Para obtener los flujos capturados en el trace, creé la función <code>get_flow_summary</code>. Esta función devolverá la lista de los flujos capturados. Verás detalles como origen/destino, aplicación y protocolo. Esto es útil para identificar el flujo cuyo id te interesa para obtener más detalles.</p>
<p>Creé la función <code>trace_readou</code>t para obtener un resumen de los eventos que el trace capturó junto con el camino afectado. Por ejemplo, podrías ver que un flujo SSH no está funcionando entre el Dispositivo X y el Dispositivo Y.</p>
<p>Una vez que hayas identificado el flujo y los eventos que te interesan, puedes obtener información detallada del flujo con la función <code>get_flow_detai</code>. Esto te proporcionará información como:</p>
<ul>
<li>Hops</li>
<li>Eventos</li>
<li>Colores locales/remotos</li>
<li>Interfaces de entrada/salida</li>
<li>Funcionalidades de entrada/salida aplicadas a los paquetes</li>
<li>Funcionalidad que determina decisión de ruteo</li>
</ul>
<p>Con esta información es posible ver todo tipo de cosas, como ACLs, tipo de políticas aplicadas, por qué un paquete fue enviado a través de un color específico, caídas, confirmar que tu política está funcionando como se espera, etc.</p>
<p>Ok, creo que eso es todo</p>
<h2 id="demo">Demo<a hidden class="anchor" aria-hidden="true" href="#demo">#</a></h2>
<p>Comencé creando un ACL para bloquear la comunicación y la apliqué en el lado de DC.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Munich_DC100-1 - ACL configuration
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sdwan
</span></span><span style="display:flex;"><span> interface GigabitEthernet2
</span></span><span style="display:flex;"><span>  access-list ACL_Drop_172_16_10_0 out
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>policy
</span></span><span style="display:flex;"><span> access-list ACL_Drop_172_16_10_0
</span></span><span style="display:flex;"><span>  sequence 1
</span></span><span style="display:flex;"><span>   match
</span></span><span style="display:flex;"><span>    source-ip      172.16.10.0/24
</span></span><span style="display:flex;"><span>    destination-ip 172.16.100.0/24
</span></span><span style="display:flex;"><span>   !
</span></span><span style="display:flex;"><span>   action drop
</span></span><span style="display:flex;"><span>    count dropCounter
</span></span><span style="display:flex;"><span>   !
</span></span><span style="display:flex;"><span>  !
</span></span><span style="display:flex;"><span>  default-action accept
</span></span><span style="display:flex;"><span> !
</span></span></code></pre></div><p>¿Mi asistente detectará esto? 🤔</p>
<p>A continuación, comienzo la aplicación y solicito que el LLM inicie una traza. Puedo confirmar en la UI que se crea.</p>
<p><img loading="lazy" src="/wp-Content/uploads/2024/07/starttrace.png"><img loading="lazy" src="/wp-content/uploads/2024/07/ui-trace.png"></p>
<p>Lanzo un par de conexiones SSH de Branch a DC</p>
<p><img loading="lazy" src="/wp-content/uploads/2024/07/sshs.png"></p>
<p>Después, le pregunto al asistente si se han capturado flujos, responde con esto</p>
<p><img loading="lazy" src="/wp-content/uploads/2024/07/events.png"></p>
<p>Podemos ver que los flujos fueron capturados y también me dio más información sobre los eventos detectados y el camino que tomaron los paquetes incluyendo los nombres de los dispositivos. El primer evento parece estar relacionado con nuestro problema. Hasta ahora, la información parece precisa, voy a pedir más detalles.</p>
<p><img loading="lazy" src="/wp-content/uploads/2024/07/assistant-2.png"></p>
<p>Con esto, podemos ver que el cliente envió múltiples intentos de SSH, podemos profundizar en uno de los flujos. Veamos qué más da.</p>
<p><img loading="lazy" src="/wp-Content/uploads/2024/07/details.png"></p>
<p>Finalmente, el asistente proporciona información detallada sobre las funcionalidades que se aplican a cada uno de los flujos. En el segundo salto, en <em>Munich DC</em>, podemos ver que las <code>funcionalidades de salida</code> muestran el <code>SD-WAN ACL</code> y un &lsquo;Drop Report&rsquo;. El asistente proporciona su propia conclusión y también sospecha que el router de Munich está tirando el tráfico.</p>
<p>Con un poco más de trabajo, el agente podría decir el nombre del ACL y el número de secuencia responsable de tirar el tráfico. ¡Hemos identificado con éxito la raíz del problema! 😀 🎉</p>
<h2 id="lecciones-aprendidas">Lecciones aprendidas<a hidden class="anchor" aria-hidden="true" href="#lecciones-aprendidas">#</a></h2>
<ul>
<li>Cuando comencé, quería ser súper cauteloso con los créditos ($$), así que estaba usando GPT-3.5-Turbo-16k que es más barato pero también menos inteligente. En algún momento, enfrenté problemas con el LLM entrando en un loop, decidí probar GPT-4O y sentí una diferencia en la forma en que el agente estaba razonando.</li>
<li>Inicialmente, estaba usando una temperatura LLM = 0, esto estaba bien, pero las respuestas carecían de variedad y detalles, necesitaba hacerlo más hablador. Ajustar la temperatura = 0.9 me dio un buen equilibrio entre la charla y la corrección (aunque a veces el agente todavía proporciona información que es <em>cuestionable</em> en función de las salidas)</li>
<li>Hacer troubleshooting puede ser difícil a veces, principalmente me basé en imprimir los resultados de las funciones mientras estas se ejecutaban y el agente imprimía en la terminal. Esto me permitió entender qué herramientas estaba utilizando el agente y el orden en que las utilizaba. Además, pude ver qué estaban devolviendo esas herramientas. Aquí tienes un ejemplo:</li>
</ul>
<p><img loading="lazy" src="/wp-content/uploads/2024/07/terminal.png"></p>
<p>El texto en verde indica las herramientas a las que está accediendo al agente. El texto amarillo es la información devuelta por una función. En este caso, podemos ver que el agente llamó la función <code>&quot;get_entry_time_and_state&quot;</code> para que obtener información necesaria para llamar a la siguiente función <code>&quot;get_flow_detail&quot;</code></p>
<p>Hay mejores herramientas disponibles para ayudar con la resolución de problemas como <a href="https://python.langchain.com/v0.2/docs/how_to/debugging/">LangSmith Tracing</a>, lo voy a explorar en el futuro.</p>
<ul>
<li>El prompts de mi agente tuvo que ser refinado varias veces, a menudo me di cuenta de que necesitaba proporcionar más detalles para manejar ciertas situaciones correctamente, especialmente cuando la salida de una función era necesaria para llamar a otra o para manejar situaciones inesperadas. Creo que aún puede mejorarse, de hecho, quiero escribir un prompt completamente diferente para intentar hacer que el agente ejecute todas las herramientas por sí mismo y solo devuelva una conclusión después de analizar todas las salidas.</li>
</ul>
<h2 id="conclusión">Conclusión<a hidden class="anchor" aria-hidden="true" href="#conclusión">#</a></h2>
<p>En general, fue un buen y largo ejercicio de aprendizaje esto de construir mi primer asistente. Me siento contento con el resultado, ya que logré alcanzar mi objetivo. Al mismo tiempo, reconozco que hay muchas cosas que se pueden mejorar para hacer que los resultados sean más confiables y significativos. Además, hay mucha más información que NWPI puede mostrar, por lo que las herramientas definitivamente se pueden ampliar.</p>
<p>Como siguiente paso, planeo aprender LangChain adecuadamente y entender cómo puedo implementar múltiples agentes para mejorar la funcionalidad y confiabilidad de mi asistente.</p>
<p>¡Espero que este post te ayude de la misma manera que la presentación de Cisco Live me ayudó a mí!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer><script src="https://utteranc.es/client.js"
        repo="aruiz-p/netwithalex"
        issue-term="title"
        label="comments"
        theme="preferred-color-scheme"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/es/">NetWithAlex</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copiar';

        function copyingDone() {
            copybutton.innerHTML = '¡copiado!';
            setTimeout(() => {
                copybutton.innerHTML = 'copiar';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
